(self.webpackChunkgilatod_app_metaverse=self.webpackChunkgilatod_app_metaverse||[]).push([[179],{620:(n,e,t)=>{var r=t(911),a=r.lua,i=r.lauxlib,u=r.L,o=r.interop.push;i.luaL_getsubtable(u,a.LUA_REGISTRYINDEX,i.LUA_PRELOAD_TABLE),a.lua_pushcfunction(u,(function(n){return o(n,t(979)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.guard")),a.lua_pushcfunction(u,(function(n){return o(n,t(169)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.meta")),a.lua_pushcfunction(u,(function(n){return o(n,t(838)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.tablex")),a.lua_pushcfunction(u,(function(n){return o(n,t(786)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.pattern")),a.lua_pushcfunction(u,(function(n){return o(n,t(254)),1})),a.lua_setfield(u,-2,r.to_luastring("phale.object")),a.lua_pushcfunction(u,(function(n){return o(n,t(974)),1})),a.lua_setfield(u,-2,r.to_luastring("phale.effect")),a.lua_pushcfunction(u,(function(n){return o(n,t(435)),1})),a.lua_setfield(u,-2,r.to_luastring("phale-std")),a.lua_pop(u,1),n.exports=r.load('local guard = require("meido.guard")\nlocal meta = require("meido.meta")\nlocal tablex = require("meido.tablex")\nlocal p = require("meido.pattern")\n\nlocal object = require("phale.object")\nlocal effect = require("phale.effect")\n\nlocal prelude = require("phale-std")\n\nlocal function load()\n    print(tablex.show(prelude.replicate(effect("asdf"),\n        object.memorize(function() return 2 end) + "1" ^ object.memorize(function() return 1 end))))\nend\n\ncoroutine.wrap(function()\n    xpcall(load, function(err)\n        print(err)\n        print(debug.traceback())\n    end)\nend)()',"@./Users/tylerling/Documents/Projects/gilatod/packages/gilatod-app-metaverse/src/bootstrap.lua").call("./bootstrap.lua")},338:(n,e,t)=>{var r=t(911);n.exports=r.load('local random = math.random\nlocal remove = table.remove\n\nlocal array = {}\n\narray.find = function(t, item)\n    for i = 1, #t do\n        if t[i] == item then\n            return i\n        end\n    end\n    return false\nend\n\narray.find_all = function(t, item)\n    local res = {}\n    for i = 1, #t do\n        if t[i] == item then\n            res[#res+1] = item\n        end\n    end\n    return res\nend\n\narray.find_for = function(t, f)\n    for i = 1, #t do\n        if f(t[i]) then\n            return i\n        end\n    end\n    return false\nend\n\narray.find_all_for = function(t, f)\n    local res = {}\n    for i = 1, #t do\n        if f(t[i]) then\n            res[#res+1] = item\n        end\n    end\n    return res\nend\n\narray.remove_item = function(t, item)\n    for i = 1, #t do\n        if t[i] == item then\n            remove(t, i)\n            return true\n        end\n    end\n    return false\nend\n\narray.remove_all_items = function(t, item)\n    local c = 0\n    local i = 1\n    while i <= #t do\n        if t[i] == item then\n            remove(t, i)\n            c = c + 1\n        else\n            i = i + 1\n        end\n    end\n    return c\nend\n\narray.remove_for = function(t, f)\n    for i = 1, #t do\n        if f(t[i]) then\n            remove(t, i)\n            return true\n        end\n    end\n    return false\nend\n\narray.remove_all_for = function(t, f)\n    local c = 0\n    local i = 1\n    while i <= #t do\n        if f(t[i]) then\n            remove(t, i)\n            c = c + 1\n        else\n            i = i + 1\n        end\n    end\n    return c\nend\n\narray.clear = function(t)\n    local count = #t\n    for i = 1, #count do\n        t[i] = nil\n    end\n    return t\nend\n\narray.equal = function(t1, t2)\n    if #t1 ~= #t2 then\n        return false\n    end\n\n    for i = 1, #t1 do\n        if t1[i] ~= t2[i] then\n            return false\n        end\n    end\n\n    return true\nend\n\narray.append = function(t1, t2)\n    local init = #t1\n    for i = 1, #t2 do\n        t1[init + i] = t2[i]\n    end\n    return t1\nend\n\narray.concat = function(ts, f)\n    f = f or array.append\n\n    local res = {}\n    for i = 1, #ts do\n        res = f(res, ts[i])\n    end\n    return res\nend\n\narray.clone = function(t)\n    local r = {}\n    for i = 1, #t do\n        r[i] = t[i]\n    end\n    return r\nend\n\narray.map = function(t, f)\n    local res = {}\n    for i = 1, #t do\n        res[i] = f(t[i])\n    end\n    return res\nend\n\narray.fold = function(initial, t, f)\n    local acc = initial\n    for i = 1, #t do\n        acc = f(acc, t[i])\n    end\n    return acc\nend\n\narray.reduce = function(t, f)\n    assert(#t ~= 0, "empty array")\n\n    local acc = t[1]\n    for i = 2, #t do\n        acc = f(acc, t[i])\n    end\n    return acc\nend\n\narray.fold_rev = function(t, initial, f)\n    local acc = initial\n    for i = #t, 1, -1 do\n        acc = f(t[i], acc)\n    end\n    return acc\nend\n\narray.reduce_rev = function(t, f)\n    assert(#t ~= 0, "empty array")\n\n    local v = t[#t]\n    for i = #t - 1, 1, -1 do\n        v = f(t[i], v)\n    end\n    return v\nend\n\narray.reverse = function(t)\n    local i, j = 1, #t\n    while i < j do\n        t[i], t[j] = t[j], t[i]\n        i = i + 1\n        j = j - 1\n    end\n    return t\nend\n\narray.shuffle = function(t)\n    local c = #t\n    for i = 1, c do\n        local j = random(1, c)\n        t[j], t[i] = t[i], t[j]\n    end\n    return t\nend\n\narray.clear = function(t)\n    for i = 1, #t do\n        t[i] = nil\n    end\n    return t\nend\n\narray.generate = function(count_or_array, f)\n    local t = {}\n\n    if type(count_or_array) == "number" then\n        for i = 1, count_or_array do\n            t[i] = f(i)\n        end\n    else\n        for i = 1, #count_or_array do\n            t[i] = f(i, count_or_array[i])\n        end\n    end\n\n    return t\nend\n\nreturn array',"@./Users/tylerling/Documents/Projects/gilatod/packages/meido/src/array.lua").call("./array.lua")},979:(n,e,t)=>{var r=t(911),a=r.lua,i=r.lauxlib,u=r.L,o=r.interop.push;i.luaL_getsubtable(u,a.LUA_REGISTRYINDEX,i.LUA_PRELOAD_TABLE),a.lua_pushcfunction(u,(function(n){return o(n,t(838)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.tablex")),a.lua_pop(u,1),n.exports=r.load('local tablex = require("meido.tablex")\n\nlocal math_type = math.type\n\nlocal guard = {}\n\nlocal __error = error\nlocal function error(...)\n    print(debug.traceback())\n    __error(...)\nend\n\nlocal function inspect(v)\n    if not guard.inspect_enabled then\n        return ""\n    end\n    return ", got "..tablex.show(v)\nend\n\nguard.set_inspect_enabled = function(enabled)\n    guard.inspect_enabled = enabled\nend\n\nguard.is_inspect_enabled = function()\n    return guard.inspect_enabled\nend\n\n-- relational guards\n\nguard.equal = function(name, v, other)\n    if v ~= other then\n        error(name.." is expected to be "..\n            tostring(other)..inspect(v))\n    end\nend\n\nguard.non_equal = function(name, v, other)\n    if v == other then\n        error(name.." cannot be "..\n            tostring(other))\n    end\nend\n\nguard.greater = function(name, v, comparand)\n    guard.non_nil(name, v)\n    if v <= comparand then\n        error(name.." must be greater than "..\n            comparand..inspect(v))\n    end\nend\n\nguard.greater_or_equal = function(name, v, comparand)\n    guard.non_nil(name, v)\n    if v < comparand then\n        error(name.." must be greater or equal to "..\n            comparand..inspect(v))\n    end\nend\n\nguard.less = function(name, v, comparand)\n    guard.non_nil(name, v)\n    if v >= comparand then\n        error(name.." must be less than "..\n            comparand..inspect(v))\n    end\nend\n\nguard.less_or_equal = function(name, v, comparand)\n    guard.non_nil(name, v)\n    if v > comparand then\n        error(name.." must be less or equal to "..\n            comparand..inspect(v))\n    end\nend\n\n-- type guards\n\nlocal function create_type_guard(expected_type)\n    return function(name, v)\n        local t = type(v)\n        if t ~= expected_type then\n            error(name.." must be "..expected_type..inspect(v))\n        end\n    end\nend\n\nguard.string  = create_type_guard("string")\nguard.number  = create_type_guard("number")\nguard.func    = create_type_guard("function")\nguard.table   = create_type_guard("table")\nguard.boolean = create_type_guard("boolean")\n\n-- nil guards\n\nguard.is_nil = function(name, v)\n    if v ~= nil then\n        error(name.." must be nil"..inspect(v))\n    end\nend\n\nguard.non_nil = function(name, v)\n    if v == nil then\n        error(name.." cannot be nil")\n    end\nend\n\n-- string guards\n\nguard.empty_string = function(name, v)\n    guard.string(name, v)\n    if v ~= "" then\n        error(name.." must be empty string"..inspect(v))\n    end\nend\n\nguard.nonempty_string = function(name, v)\n    guard.string(name, v)\n    if v == "" then\n        error(name.." must be non-empty string")\n    end\nend\n\n-- number guards\n\nguard.integer = function(name, v)\n    if math_type(v) ~= "integer" then\n        error(name.." must be integer"..inspect(v))\n    end\nend\n\nguard.float = function(name, v)\n    if math_type(v) ~= "float" then\n        error(name.." must be float"..inspect(v))\n    end\nend\n\nguard.zero = function(name, v)\n    guard.number(name, v)\n    if v ~= 0 then\n        error(name.." must be zero"..inspect(v))\n    end\nend\n\nguard.non_zero = function(name, v)\n    guard.number(name, v)\n    if v == 0 then\n        error(name.." must be non-zero")\n    end\nend\n\nguard.finite = function(name, v)\n    guard.number(name, v)\n    if v == math.huge then\n        error(name.." must be finite number")\n    end\nend\n\nguard.positive = function(name, v)\n    guard.number(name, v)\n    if v <= 0 then\n        error(name.." must be positive number"..inspect(v))\n    end\nend\n\nguard.zero_or_positive = function(name, v)\n    guard.number(name, v)\n    if v < 0 then\n        error(name.." must be zero or positive"..inspect(v))\n    end\nend\n\nguard.negative = function(name, v)\n    guard.number(name, v)\n    if v >= 0 then\n        error(name.." must be negative number"..inspect(v))\n    end\nend\n\nguard.zero_or_negative = function(name, v)\n    guard.number(name, v)\n    if v > 0 then\n        error(name.." must be zero or negative"..inspect(v))\n    end\nend\n\nguard.odd = function(name, v)\n    guard.number(name, v)\n    if v % 2 == 0 then\n        error(name.." must be odd number"..inspect(v))\n    end\nend\n\nguard.even = function(name, v)\n    guard.number(name, v)\n    if v % 2 == 1 then\n        error(name.." must be even number"..inspect(v))\n    end\nend\n\n-- table guards\n\nlocal function create_table_guard(raw_type, metamethod, info)\n    return function(name, v)\n        local t = type(v)\n\n        if t == raw_type then\n            return\n        elseif t == "table" then\n            local meta = getmetatable(v)\n            if meta and type(meta[metamethod]) == "function" then\n                return\n            end\n        end\n\n        error(name.." must "..info..inspect(v))\n    end\nend\n\nguard.callable   = create_table_guard("function", "__call", "be callable")\nguard.concatable = create_table_guard("string", "__concat", "be concatable")\nguard.interable  = create_table_guard("table", "__pairs", "be interable")\nguard.can_add    = create_table_guard("number", "__add", "support addition")\nguard.can_sub    = create_table_guard("number", "__sub", "support subtraction")\nguard.can_mul    = create_table_guard("number", "__mul", "support multiplication")\nguard.can_div    = create_table_guard("number", "__div", "support division")\nguard.can_mod    = create_table_guard("number", "__mod", "support modulus")\nguard.can_unm    = create_table_guard("number", "__unm", "support negation")\nguard.can_pow    = create_table_guard("number", "__pow", "support exponentiation")\nguard.can_lt     = create_table_guard("number", "__lt", "support less-than operator")\nguard.can_le     = create_table_guard("number", "__le", "support less-or-equal operator")\nguard.can_idiv   = create_table_guard("number", "__idiv", "support floor division operator")\nguard.can_band   = create_table_guard("number", "__band", "support bitwise AND operator")\nguard.can_bor    = create_table_guard("number", "__bor", "support bitwise OR operator")\nguard.can_bxor   = create_table_guard("number", "__bxor", "support bitwise XOR operator")\nguard.can_bnot   = create_table_guard("number", "__bnot", "support bitwise NOT operator")\nguard.can_shl    = create_table_guard("number", "__shl", "support bitwise left shift operator")\nguard.can_shr    = create_table_guard("number", "__shl", "support bitwise right shift operator")\n\n-- boolean guards\n\nguard.truthy = function(name, v)\n    if not v then\n        error(name.." must be truthy"..inspect(v))\n    end\nend\n\nguard.falsy = function(name, v)\n    if v then\n        error(name.." must be falsy"..inspect(v))\n    end\nend\n\nguard.is_true = function(name, v)\n    if v ~= true then\n        error(name.." must be true"..inspect(v))\n    end\nend\n\nguard.is_false = function(name, v)\n    if v ~= false then\n        error(name.." must be false"..inspect(v))\n    end\nend\n\n-- error guards\n\nguard.no_error = function(func, ...)\n    local success, err = pcall(func, ...)\n    if not success then\n        error("unexpected error: "..err)\n    end\nend\n\nguard.match_error = function(pattern, func, ...)\n    local success, err = pcall(func, ...)\n    if success then\n        error("no error")\n    end\n    assert(string.match(err, pattern), "error does not match: "..err)\nend\n\nreturn guard',"@./Users/tylerling/Documents/Projects/gilatod/packages/meido/src/guard.lua").call("./guard.lua")},169:(n,e,t)=>{var r=t(911),a=r.lua,i=r.lauxlib,u=r.L,o=r.interop.push;i.luaL_getsubtable(u,a.LUA_REGISTRYINDEX,i.LUA_PRELOAD_TABLE),a.lua_pushcfunction(u,(function(n){return o(n,t(979)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.guard")),a.lua_pop(u,1),n.exports=r.load('local guard = require("meido.guard")\nlocal meta = {}\n\nlocal ungrowable_meta = {\n    __metatable = "ungrowable",\n    __newindex = function()\n        error("this table is ungrowable", 2)\n    end\n}\n\nmeta.ungrowable = function(t)\n    guard.table("t", t)\n    local mt = getmetatable(t)\n    if mt == "ungrowable" then\n        return t\n    elseif mt then\n        error("table has another metatable")\n    end\n    return setmetatable(t, ungrowable_meta)\nend\n\nmeta.readonly = function(t)\n    guard.table("t", t)\n    return setmetatable({}, {\n        __metatable = "readonly",\n        __index = function(t, k)\n            return t[k]\n        end,\n        __newindex = function()\n            error("this table is read-only", 2)\n        end,\n        __pairs = function() return pairs(t) end,\n        __ipairs = function() return ipairs(t) end\n    })\nend\n\nmeta.writeonly = function(t, write)\n    guard.table("t", t)\n    guard.callable("write", write)\n    return setmetatable({}, {\n        __metatable = "writeonly",\n        __index = function()\n            error("this table is write-only", 2)\n        end,\n        __newindex = function(t, k, v)\n            write(t, k, v)\n        end\n    })\nend\n\nreturn meta',"@./Users/tylerling/Documents/Projects/gilatod/packages/meido/src/meta.lua").call("./meta.lua")},786:(n,e,t)=>{var r=t(911),a=r.lua,i=r.lauxlib,u=r.L,o=r.interop.push;i.luaL_getsubtable(u,a.LUA_REGISTRYINDEX,i.LUA_PRELOAD_TABLE),a.lua_pushcfunction(u,(function(n){return o(n,t(979)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.guard")),a.lua_pushcfunction(u,(function(n){return o(n,t(169)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.meta")),a.lua_pushcfunction(u,(function(n){return o(n,t(338)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.array")),a.lua_pop(u,1),n.exports=r.load('local guard = require("meido.guard")\nlocal meta = require("meido.meta")\nlocal array = require("meido.array")\n\nlocal clear = array.clear\nlocal ungrowable = meta.ungrowable\nlocal readonly = meta.readonly\nlocal format = string.format\nlocal concat = table.concat\nlocal insert = table.insert\nlocal math_type = math.type\n\nif math_type == nil then\n    math_type = function(n)\n        if type(n) ~= "number" then\n            return nil\n        end\n        local _, f = math.modf(n)\n        return f == 0\n            and "integer" or "float"\n    end\nend\n\nlocal EMPTY_TABLE = ungrowable {}\nlocal NO_DEFAULT = ungrowable {}\n\nlocal pattern = setmetatable({}, {\n    __call = function(self, category, default, desc_func, match_func)\n        guard.nonempty_string("category", category)\n        guard.callable("desc_func", desc_func)\n        guard.callable("match_func", match_func)\n\n        local t = {\n            category = category,\n            default = default,\n            desc_func = desc_func,\n            match_func = match_func\n        }\n\n        if default == NO_DEFAULT then\n            -- override pattern:get_default\n            function t:get_default()\n                error("no default")\n            end\n        elseif not match_func(default) then\n            error("invalid default value")\n        end\n\n        return setmetatable(t, self)\n    end\n})\npattern.__index = pattern\n\npattern.NO_DEFAULT = NO_DEFAULT\n\nfunction pattern:has_default()\n    return self.default ~= NO_DEFAULT\nend\n\nfunction pattern:get_default()\n    return self.default\nend\n\nfunction pattern:__tostring()\n    return self.desc_func()\nend\n\nfunction pattern:get_description()\n    return self.desc_func()\nend\n\nfunction pattern:match(value, collection, stack)\n    if stack then\n        stack[#stack+1] = {self, value}\n        local res = self.match_func(value, collection, stack)\n        if res then stack[#stack] = nil end\n        return res\n    else\n        return self.match_func(value, collection)\n    end\nend\n\nfunction pattern:guard(name, value)\n    if not self:match(value) then\n        error(name.." must be "..self.category)\n    end\nend\n\nfunction to_pattern(p)\n    if type(p) == "table" then\n        local to_pattern = p.to_pattern\n        if pattern.CALLABLE:match(to_pattern) then\n            return to_pattern(p)\n        end\n    end\n\n    local mt = getmetatable(p)\n    if mt == pattern then\n        return p\n    elseif type(mt) == "table"\n        and getmetatable(mt.__index) == pattern then\n        return p\n    end\nend\n\nfunction require_pattern(p, text)\n    local p = to_pattern(p)\n    if p then return p end\n    error(text or "invalid pattern", 2)\nend\n\npattern.from = to_pattern\npattern.require = require_pattern\n\n-- basic patterns\n\nlocal function basic_pattern(type_name, default)\n    return pattern("basic", default,\n        function() return type_name end,\n        function(v) return type(v) == type_name end)\nend\n\npattern.NIL      = basic_pattern("nil", nil)\npattern.STRING   = basic_pattern("string", "")\npattern.NUMBER   = basic_pattern("number", 0)\npattern.TABLE    = basic_pattern("table", EMPTY_TABLE)\npattern.FUNCTION = basic_pattern("function", NO_DEFAULT)\npattern.BOOLEAN  = basic_pattern("boolean", false)\n\npattern.ANY = pattern("basic", nil,\n    function() return "any" end,\n    function(v) return true end)\n\npattern.VOID = pattern("basic", NO_DEFAULT,\n    function() return "void" end,\n    function(v) return false end)\n\npattern.NON_NIL = pattern("basic", false,\n    function() return "non_nil" end,\n    function(v) return v ~= nil end)\n\npattern.TRUTHY = pattern("basic", true,\n    function() return "truthy" end,\n    function(v) return v end)\n\npattern.FALSY = pattern("basic", false,\n    function() return "falsy" end,\n    function(v) return not v end)\n\npattern.value = function(value)\n    local pat = pattern("value", value,\n        function()\n            if type(value) == "string" then\n                return format("\\"%s\\"", value)\n            else\n                return tostring(value)\n            end\n        end,\n        function(v) return v == value end)\n\n    function pat:get_value()\n        return value\n    end\n\n    return pat\nend\n\npattern.collect = function(key, mapper)\n    guard.non_nil("key", key)\n    local match_func\n    if mapper then\n        guard.callable("mapper", mapper)\n        match_func = function(v, c)\n            if c then\n                local result = mapper(v)\n                if result then\n                    c[key] = result\n                    return true\n                else\n                    return false\n                end\n            end\n        end\n    else\n        match_func = function(v, c)\n            if c then\n                c[key] = v\n            end\n            return true\n        end\n    end\n\n    local pat = pattern("collect", NO_DEFAULT,\n        function() return "@"..tostring(index) end,\n        match_func)\n    \n    function pat:get_key()\n        return key\n    end\n\n    return pat\nend\n\n-- combinators\n\npattern.no_default = function(pat)\n    pat = require_pattern(pat)\n\n    local new_pat = pattern("no_default", NO_DEFAULT,\n        function() return format("no_default[%s]", pat) end,\n        function(v, c, s) return pat:match(v, c, s) end)\n    \n    function new_pat:get_raw_pattern()\n        return pat\n    end\n\n    return new_pat\nend\n\npattern.with_default = function(pat, default)\n    pat = require_pattern(pat)\n    assert(pat:match(default), "invalid default value")\n\n    local new_pat = pattern("with_default", default,\n        function()\n            return format("with_default[%s, %s]",\n                pat, default)\n        end,\n        function(v, c, s) return pat:match(v, c, s) end)\n    \n    function new_pat:get_raw_pattern()\n        return pat\n    end\n\n    return new_pat\nend\n\npattern.named = function(pat, name)\n    pat = require_pattern(pat)\n    guard.nonempty_string("name", name)\n    \n    local new_pat = pattern("named", pat.default,\n        function() return name end,\n        function(v, c, s) return pat:match(v, c, s) end)\n    \n    function new_pat:get_raw_pattern()\n        return pat\n    end\n\n    return new_pat\nend\n\npattern.union = function(...)\n    local subpats = {...}\n    if #subpats == 0 then\n        error("no subpattern provided")\n    end\n\n    for i = 1, #subpats do\n        local subpat = to_pattern(subpats[i])\n        if not subpat then\n            error("invalid subpattern at index #"..i)\n        end\n    end\n\n    local default = NO_DEFAULT\n\n    for i = 1, #subpats do\n        local subpat = subpats[i]\n        if subpat:has_default() then\n            default = subpat:get_default()\n            break\n        end\n    end\n\n    local pat = pattern(\n        "union", default,\n        function()\n            local res = {}\n            for i = 1, #subpats do\n                res[#res+1] = subpats[i]:get_description()\n                res[#res+1] = " | "\n            end\n            res[#res] = nil\n            return concat(res)\n        end,\n        function(v, c, s)\n            for i = 1, #subpats do\n                if subpats[i]:match(v, c, s) then\n                    return true\n                end\n            end\n            return false\n        end)\n    \n    function pat:get_subpatterns()\n        return readonly(subpats)\n    end\n\n    return pat\nend\n\npattern.intersect = function(...)\n    local subpats = {...}\n    if #subpats == 0 then\n        error("no subpattern provided")\n    end\n\n    for i = 1, #subpats do\n        local subpat = to_pattern(subpats[i])\n        if not subpat then\n            error("invalid subpattern at index #"..i)\n        end\n    end\n\n    local default\n    \n    for i = 1, #subpats do\n        default = subpats[i].default\n        if default == NO_DEFAULT then\n            goto skip\n        end\n        for j = 1, #subpats do\n            if i ~= j\n                and not subpats[j]:match(default) then\n                default = NO_DEFAULT\n                break\n            end\n        end\n        ::skip::\n    end\n    \n    local pat = pattern(\n        "intersect", default,\n        function()\n            local res = {}\n            for i = 1, #subpats do\n                res[#res+1] = subpats[i]:get_description()\n                res[#res+1] = " & "\n            end\n            res[#res] = nil\n            return concat(res)\n        end,\n        function(v, c, s)\n            for i = 1, #subpats do\n                if not subpats[i]:match(v, c, s) then\n                    return false\n                end\n            end\n            return true\n        end)\n    \n    function pat:get_subpatterns()\n        return readonly(subpats)\n    end\n\n    return pat\nend\n\npattern.recurse = function(name, pattern_creator)\n    guard.nonempty_string("name", name)\n    guard.callable("pattern_creator", pattern_creator)\n\n    local pat\n\n    local hook_pat = pattern("recursion", NO_DEFAULT,\n        function() return name end,\n        function(v, c, s)\n            return pat:match(v, c, s)\n        end)\n\n    pat = pattern_creator(hook_pat)\n    pat = require_pattern(pat, "invalid pattern creator")\n\n    return pattern("recurse", pat.default,\n        function() return format("%s : %s", name, pat) end,\n        function(v, c, s)\n            return pat:match(v, c, s)\n        end)\nend\n\n-- nilable patterns\n\nlocal function basic_nilable(type_name)\n    return pattern("nilable", nil,\n        function() return "?"..type_name end,\n        function(v) return v == nil or type(v) == type_name end)\nend\n\npattern.STRING_OR_NIL   = basic_nilable("string")\npattern.NUMBER_OR_NIL   = basic_nilable("number")\npattern.TABLE_OR_NIL    = basic_nilable("table")\npattern.FUNCTION_OR_NIL = basic_nilable("function")\npattern.BOOLEAN_OR_NIL  = basic_nilable("boolean")\n\npattern.nilable = function(pat)\n    pat = require_pattern(pat)\n    \n    local new_pat = pattern("nilable", nil,\n        function() return format("?%s", pat) end,\n        function(v, c, s) return v == nil or pat:match(v, c, s) end)\n    \n    function new_pat:get_raw_pattern()\n        return pat\n    end\n\n    return new_pat\nend\n\n-- numeric patterns\n\npattern.NONNEGATIVE_NUMBER = pattern("numeric", 0,\n    function() return "nonnegative_number" end,\n    function(v) return type(v) == "number" and v >= 0 end)\n\npattern.NONPOSITIVE_NUMBER = pattern("numeric", 0,\n    function() return "nonpositive_number" end,\n    function(v) return type(v) == "number" and v <= 0 end)\n\npattern.NORMALIZED_NUMBER = pattern("numeric", 0,\n    function() return "normalized_number" end,\n    function(v) return type(v) == "number" and v >= 0 and v <= 1 end)\n\npattern.INTEGER = pattern("numeric", 0,\n    function() return "integer" end,\n    function(v) return math_type(v) == "integer" end)\n\npattern.INTEGER_OR_NIL = pattern("numeric", nil,\n    function() return "integer?" end,\n    function(v) return v == nil or math_type(v) == "integer" end)\n\npattern.POSITIVE_INTEGER = pattern("numeric", 1,\n    function() return "positive_integer" end,\n    function(v) return math_type(v) == "integer" and v > 0 end)\n\npattern.NONPOSITIVE_INTEGER = pattern("numeric", 0,\n    function() return "nonpositive_integer" end,\n    function(v) return math_type(v) == "integer" and v <= 0 end)\n\npattern.NEGATIVE_INTEGER = pattern("numeric", -1,\n    function() return "negative_integer" end,\n    function(v) return math_type(v) == "integer" and v < 0 end)\n\npattern.NONNEGATIVE_INTEGER = pattern("numeric", 0,\n    function() return "nonnegative_integer" end,\n    function(v) return math_type(v) == "integer" and v >= 0 end)\n\npattern.EVEN_INTEGER = pattern("numeric", 0,\n    function() return "even_integer" end,\n    function(v) return v % 2 == 0 end)\n\npattern.ODD_INTEGER = pattern("numeric", 1,\n    function() return "odd_integer" end,\n    function(v) return v % 2 == 1 end)\n\npattern.POSITIVE_EVEN_INTEGER = pattern("numeric", 2,\n    function() return "positive_even_integer" end,\n    function(v) return v > 0 and v % 2 == 0 end)\n\npattern.POSITIVE_ODD_INTEGER = pattern("numeric", 1,\n    function() return "positive_odd_integer" end,\n    function(v) return v > 0 and v % 2 == 1 end)\n\npattern.NEGATIVE_EVEN_INTEGER = pattern("numeric", -2,\n    function() return "negative_even_integer" end,\n    function(v) return v < 0 and v % 2 == 0 end)\n\npattern.NEGATIVE_ODD_INTEGER = pattern("numeric", -1,\n    function() return "negative_odd_integer" end,\n    function(v) return v < 0 and v % 2 == 1 end)\n\npattern.NONNEGATIVE_EVEN_INTEGER = pattern("numeric", 0,\n    function() return "nonnegative_even_integer" end,\n    function(v) return v >= 0 and v % 2 == 0 end)\n\npattern.range = function(min_value, max_value)\n    guard.non_nil("min_value", min_value)\n    guard.non_nil("max_value", max_value)\n\n    local pat = pattern("range", min_value,\n        function()\n            return format("[%s ~ %s]", min_value, max_value)\n        end,\n        function(v, c)\n            local succ, res = pcall(function()\n                return min_value <= v and v <= max_value\n            end)\n            return succ, res\n        end)\n\n    function pat:get_min()\n        return min_value\n    end\n\n    function pat:get_max()\n        return max_value\n    end\n\n    return pat\nend\n\n-- string patterns\n\npattern.NONEMPTY_STRING = pattern("string", NO_DEFAULT,\n    function() return "nonempty_string" end,\n    function(v) return type(v) == "string" and #v > 0 end)\n\npattern.regex = function(regex)\n    guard.string("regex", regex)\n\n    local pat = pattern("string", "",\n        function()\n            return format("/%s/", regex)\n        end,\n        function(v)\n            return type(v) == "string" and find(regex, v)\n        end)\n    \n    function pat:get_regex()\n        return regex\n    end\n\n    return pat\nend\n\n-- callable patterns\n\npattern.CALLABLE = pattern("callable", NO_DEFAULT,\n    function() return "callable" end,\n    function(v)\n        if type(v) == "function" then\n            return true\n        end\n        local mt = getmetatable(v)\n        return type(mt) == "table" and mt.__call\n    end)\n\npattern.CALLABLE_OR_NIL = pattern("callable", nil,\n    function() return "?callable" end,\n    function(v)\n        if not v or type(v) == "function" then\n            return true\n        end\n        local mt = getmetatable(v)\n        return type(mt) == "table" and mt.__call\n    end)\n\n-- meta patterns\n\npattern.meta = function(name, metatable)\n    guard.nonempty_string("name", name)\n    guard.table("metatable", metatable)\n\n    local pat = pattern("meta", nil,\n        function()\n            return "%"..name\n        end,\n        function(v)\n            return v == nil or getmetatable(v) == metatable\n        end)\n    \n    function pat:get_metatable()\n        return metatable\n    end\n\n    return pat\nend\n\n-- enum patterns\n\npattern.enum = function(items)\n    guard.table("items", items)\n\n    local item_arr = {}\n    local item_map = {}\n\n    for i = 1, #items do\n        local item = items[i]\n        if item_map[item] then\n            error("duplicate item found: "..tostring(item))\n        end\n        item_arr[i] = item\n        item_map[item] = i\n    end\n\n    local pat = pattern("enum", items[1],\n        function()\n            local res = {"("}\n            for i = 1, #item_arr do\n                local item = item_arr[i]\n                if type(item) == "string" then\n                    res[#res+1] = "\\""\n                    res[#res+1] = item\n                    res[#res+1] = "\\""\n                else\n                    res[#res+1] = tostring(item)\n                end\n                res[#res+1] = " | "\n            end\n            res[#res] = ")"\n            return concat(res)\n        end,\n        function(v)\n            return item_map[v]\n        end)\n    \n    function pat:get_items()\n        return readonly(item_arr)\n    end\n\n    return pat\nend\n\n-- table patterns\n\npattern.array = function(element_pattern)\n    pat = require_pattern(element_pattern, "invalid element pattern")\n    \n    local pat = pattern("array", EMPTY_TABLE,\n        function()\n            return format("{%s}",\n                element_pattern:get_description())\n        end,\n        function(v, c, s)\n            if type(v) ~= "table" then\n                return false\n            end\n            for i = 1, #v do\n                if not element_pattern:match(v[i], c, s) then\n                    return false\n                end\n            end\n            return true\n        end)\n    \n    function pat:get_element_pattern()\n        return element_pattern\n    end\n\n    return pat\nend\n\npattern.map = function(key_pattern, value_pattern)\n    key_pattern = require_pattern(key_pattern, "invalid key pattern")\n    value_pattern = require_pattern(value_pattern, "invalid value pattern")\n    \n    local pat = pattern("map", EMPTY_TABLE,\n        function()\n            return format("{%s => %s}",\n                key_pattern:get_description(),\n                value_pattern:get_description())\n        end,\n        function(v, c, s)\n            if type(v) ~= "table" then\n                return false\n            end\n            for key, value in pairs(v) do\n                if not key_pattern:match(key, c, s)\n                    or not value_pattern:match(value, c, s) then\n                    return false\n                end\n            end\n            return true\n        end)\n    \n    function pat:get_key_pattern()\n        return key_pattern\n    end\n\n    function pat:get_value_pattern()\n        return value_pattern\n    end\n\n    return pat\nend\n\npattern.tuple = function(...)\n    local subpats = {...}\n    if #subpats == 0 then\n        error("no subpattern provided")\n    end\n\n    local default\n\n    for i = 1, #subpats do\n        local subpat = to_pattern(subpats[i])\n        if not subpat then\n            error("invalid subpattern at index #"..i)\n        end\n        if not subpat:has_default() then\n            default = NO_DEFAULT\n        end\n    end\n\n    if default ~= NO_DEFAULT then\n        default = {}\n        for i = 1, #subpats do\n            default[i] = subpats[i]:get_default()\n        end\n    end\n\n    local pat = pattern("tuple", default,\n        function()\n            local res = {"("}\n            for i = 1, #subpats do\n                res[#res+1] = subpats[i]:get_description()\n                res[#res+1] = ", "\n            end\n            res[#res] = ")"\n            return concat(res)\n        end,\n        function(v, c, s)\n            if type(v) ~= "table" then\n                return false\n            end\n            for i = 1, #subpats do\n                if not subpats[i]:match(v[i], c, s) then\n                    return false\n                end\n            end\n            return true\n        end)\n    \n    function pat:get_subpatterns()\n        return readnoly(subpats)\n    end\n\n    return pat\nend\n\npattern.table = function(entries)\n    guard.table("entries", entries)\n    \n    local entries_cpy = {}\n    local default\n\n    for key, value_pat in pairs(entries) do\n        value_pat = to_pattern(value_pat)\n        if not value_pat then\n            error("invalid entry at index #"..i)\n        end\n\n        entries_cpy[key] = value_pat\n\n        if not value_pat:has_default() then\n            default = NO_DEFAULT\n        end\n    end\n\n    if default ~= NO_DEFAULT then\n        default = {}\n        for key, value_pat in pairs(entries) do\n            default[key] = value_pat:get_default()\n        end\n    end\n\n    local pat = pattern("table", default,\n        function()\n            local res = {"{"}\n            for key, value_pat in pairs(entries_cpy) do\n                res[#res+1] = tostring(key)\n                res[#res+1] = " = "\n                res[#res+1] = value_pat:get_description()\n                res[#res+1] = ", "\n            end\n            res[#res] = "}"\n            return concat(res)\n        end,\n        function(v, c, s)\n            if type(v) ~= "table" then\n                return false\n            end\n\n            for key, value_pat in pairs(entries_cpy) do\n                local value = v[key]\n                if not value_pat:match(value, c, s) then\n                    return false\n                end\n            end\n            return true\n        end)\n    \n    function pat:get_entries()\n        return readonly(entries_cpy)\n    end\n\n    return pat\nend\n\npattern.loop = function(...)\n    local subpats = {...}\n    if #subpats == 0 then\n        error("no subpattern provided")\n    end\n\n    for i = 1, #subpats do\n        local subpat = to_pattern(subpats[i])\n        if not subpat then\n            error("invalid subpattern at index #"..i)\n        elseif subpat:match(nil) then\n            error("pattern that matches nil cannot be used in loop")\n        end\n    end\n\n    local pat = pattern("loop", EMPTY_TABLE,\n        function()\n            local res = {"loop {"}\n            for i = 1, #subpats do\n                res[#res+1] = subpats[i]:get_description()\n                res[#res+1] = ", "\n            end\n            res[#res] = "}"\n            return concat(res)\n        end,\n        function(v, c, s)\n            if type(v) ~= "table" then\n                return false\n            end\n            local i = 1\n            while i <= #v do\n                for j = 1, #subpats do\n                    local subpat = subpats[j]\n                    if not subpat:match(v[i], c, s) then\n                        return false\n                    end\n                    i = i + 1\n                end\n            end\n            return true\n        end)\n    \n    function pat:get_subpatterns()\n        return readonly(subpats)\n    end\n\n    return pat\nend\n\nreturn pattern',"@./Users/tylerling/Documents/Projects/gilatod/packages/meido/src/pattern.lua").call("./pattern.lua")},838:(n,e,t)=>{var r=t(911);n.exports=r.load('local concat = table.concat\n\nlocal tablex = {}\n\nlocal control_escaps = {\n    ["\\a"] = "\\\\a",\n    ["\\b"] = "\\\\b",\n    ["\\f"] = "\\\\f",\n    ["\\v"] = "\\\\v",\n    ["\\n"] = "\\\\n",\n    ["\\r"] = "\\\\r"\n}\n\nlocal function format_string(str)\n    str = (str\n        :gsub("\\\\", "\\\\\\\\")\n        :gsub("\\"", "\\\\\\""))\n        :gsub("%c", control_escaps)\n    return "\\""..str.."\\""\nend\n\nlocal function is_identifier(str)\n    return type(str) == "string"\n        and str:match("^[_%a][_%a%d]*$")\nend\n\ntablex.show = function(o, initial_indent, indent)\n    local t = type(o)\n\n    if initial_indent then\n        initial_indent = tostring(initial_indent)\n        if t == "string" then\n            return initial_indent..format_string(o)\n        elseif t ~= "table" then\n            return initial_indent..tostring(o)\n        end\n    else\n        if t == "string" then\n            return format_string(o)\n        elseif t ~= "table" then\n            return tostring(o)\n        end\n    end\n    \n    if indent then\n        indent = tostring(indent)\n    else\n        indent = "    "\n    end\n\n    local root_obj = o\n\n    -- 1. first entry of the inspected\'s value is the index.\n    -- 2. second entry is the count the table is inspected.\n    -- 3. third entry will be marked as true when count > 1 and\n    --    the content of the table has been displayed.\n    local inspected = {}\n    local curr_index = 1\n\n    local function inspect(o)\n        if type(o) ~= "table" then\n            return\n        end\n\n        local entry = inspected[o]\n        if entry then\n            entry[2] = entry[2] + 1\n            if not entry[1] then\n                entry[1] = tostring(curr_index)\n                curr_index = curr_index + 1\n            end\n            return\n        else\n            inspected[o] = {nil, 1}\n        end\n\n        for k, v in next, o do\n            inspect(k)\n            inspect(v)\n        end\n    end\n\n    inspect(root_obj)\n\n    local buffer = {}\n    local formatted_strings = {}\n\n    local function raw_show(o, curr_indent)\n        local t = type(o)\n        if t == "string" then\n            local str = formatted_strings[o]\n            if not str then\n                str = format_string(o)\n                formatted_strings[o] = str\n            end\n            buffer[#buffer+1] = str\n            return\n        elseif t ~= "table" then\n            buffer[#buffer+1] = tostring(o)\n            return\n        end\n\n        local entry = inspected[o]\n\n        -- inspected more than once\n        if entry and entry[2] > 1 then\n            buffer[#buffer+1] = "<"\n            buffer[#buffer+1] = entry[1] -- index\n            buffer[#buffer+1] = ">"\n\n            local is_shown = entry[3]\n            if is_shown then return end\n\n            entry[3] = true\n            buffer[#buffer+1] = " "\n        end\n\n        buffer[#buffer+1] = "{"\n        local field_indent = curr_indent..indent\n\n        -- array elements\n        local o_len = rawlen(o)\n        for i = 1, o_len do\n            local v = rawget(o, i)\n            raw_show(v, field_indent)\n            buffer[#buffer+1] = ", "\n        end\n\n        -- map elements\n        local has_map_elem = false\n\n        for k, v in next, o do\n            if type(k) == "number" and k <= o_len then\n                goto skip\n            end\n\n            if not has_map_elem then\n                has_map_elem = true\n                buffer[#buffer+1] = "\\n"\n            end\n\n            buffer[#buffer+1] = field_indent\n\n            -- format key\n            if is_identifier(k) then\n                buffer[#buffer+1] = k\n            else\n                buffer[#buffer+1] = "["\n                raw_show(k, field_indent)\n                buffer[#buffer+1] = "]"\n            end\n\n            buffer[#buffer+1] = " = "\n\n            -- format value\n            raw_show(v, field_indent)\n\n            buffer[#buffer+1] = ",\\n"\n            ::skip::\n        end\n\n        if has_map_elem then\n            buffer[#buffer] = "\\n" -- overwrite last ",\\n"\n            buffer[#buffer+1] = curr_indent\n            buffer[#buffer+1] = "}"\n        elseif o_len > 0 then\n            buffer[#buffer] = "}" -- overwrite last ", "\n        else\n            buffer[#buffer+1] = "}"\n        end\n    end\n\n    if initial_indent then\n        buffer[1] = initial_indent\n        raw_show(root_obj, initial_indent)\n    else\n        raw_show(root_obj, "")\n    end\n    return concat(buffer)\nend\n\ntablex.equal = function(a, b)\n    local comparisons = {}\n\n    local function raw_equal(a, b)\n        if a == b then\n            return true\n        end\n\n        local a_type = type(a)\n        local b_type = type(b)\n\n        if a_type ~= b_type then\n            return false\n        end\n\n        if a_type ~= "table" then\n            return false\n        end\n\n        local compared_objs = comparisons[a]\n        if not compared_objs then\n            compared_objs = {\n                -- false denotes that comparison is in progress\n                [b] = false\n            }\n            comparisons[a] = compared_objs\n        elseif compared_objs[b] == false then\n            return true\n        end\n\n        for k, va in pairs(a) do\n            local vb = b[k]\n            if vb == nil then\n                return false\n            end\n\n            if va ~= vb then\n                local va_compared_objs = comparisons[va]\n                if (not va_compared_objs\n                    or not va_compared_objs[vb])\n                    and not raw_equal(va, vb) then\n                    return false\n                end\n            end\n        end\n\n        compared_objs[b] = true\n        return true\n    end\n\n    return raw_equal(a, b)\nend\n\ntablex.clone = function(o)\n    if type(tablex) ~= "table" then\n        return tablex\n    end\n\n    local obj_copies = {}\n\n    local function raw_copy(tablex)\n        if type(tablex) ~= "table" then\n            return tablex\n        end\n\n        local mt = getmetatable(tablex)\n        if type(mt) ~= "table"\n                or type(mt.__newindex) == "string" then\n            return tablex\n        end\n\n        local obj_copy = obj_copies[tablex]\n        if obj_copy then\n            return obj_copy\n        end\n\n        obj_copy = {}\n        obj_copies[tablex] = obj_copy\n\n        for k, v in pairs(tablex) do\n            obj_copy[raw_copy(k)] = raw_copy(v)\n        end\n\n        return setmetatable(obj_copy, mt)\n    end\n\n    return raw_copy(o)\nend\n\nreturn tablex',"@./Users/tylerling/Documents/Projects/gilatod/packages/meido/src/tablex.lua").call("./tablex.lua")},435:(n,e,t)=>{var r=t(911),a=r.lua,i=r.lauxlib,u=r.L,o=r.interop.push;i.luaL_getsubtable(u,a.LUA_REGISTRYINDEX,i.LUA_PRELOAD_TABLE),a.lua_pushcfunction(u,(function(n){return o(n,t(979)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.guard")),a.lua_pushcfunction(u,(function(n){return o(n,t(786)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.pattern")),a.lua_pushcfunction(u,(function(n){return o(n,t(974)),1})),a.lua_setfield(u,-2,r.to_luastring("phale.effect")),a.lua_pushcfunction(u,(function(n){return o(n,t(254)),1})),a.lua_setfield(u,-2,r.to_luastring("phale.object")),a.lua_pushcfunction(u,(function(n){return o(n,t(587)),1})),a.lua_setfield(u,-2,r.to_luastring("phale.typeclass")),a.lua_pop(u,1),n.exports=r.load('local guard = require("meido.guard")\nlocal p = require("meido.pattern")\n\nlocal effect = require("phale.effect")\nlocal object = require("phale.object")\nlocal typeclass = require("phale.typeclass")\n\nlocal declare = effect.declare\n\nlocal prelude = {}\n\nlocal FUNCTIONAL = typeclass("functional", {\n    call = p.CALLABLE:with_default(\n        function(imp, itp, o, ...) return itp(o)(...) end)\n})\n\nlocal MONOID = typeclass("monoid", {\n    unit = p.CALLABLE,\n    add = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) + itp(o2) end)\n})\n\nlocal NUMBER = typeclass("number", {\n    ["@"] = p.CALLABLE,\n\n    unm = p.CALLABLE:with_default(\n        function(imp, itp, o) return -itp(o) end),\n    bnot = p.CALLABLE:with_default(\n        function(imp, itp, o) return ~itp(o) end),\n\n    sub = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) - itp(o2) end),\n    mul = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) * itp(o2) end),\n    div = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) / itp(o2) end),\n    idiv = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) // itp(o2) end),\n\n    pow = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) ^ itp(o2) end),\n    mod = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) % itp(o2) end),\n    eq = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) == itp(o2) end),\n    lt = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) < itp(o2) end),\n    le = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) <= itp(o2) end),\n\n    band = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) & itp(o2) end),\n    bor = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) | itp(o2) end),\n    bxor = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) ~ itp(o2) end),\n\n    shl = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) << itp(o2) end),\n    shr = p.CALLABLE:with_default(\n        function(imp, itp, o1, o2) return itp(o1) >> itp(o2) end)\n}):inherit(FUNCTIONAL, MONOID)\n\nlocal RAW_NUMBER = NUMBER:instantiate("raw_number", {\n    ["@"] = function(interpret, value)\n        if type(value) ~= "number" then\n            typeclass.skip()\n        end\n        return value\n    end\n})\n\nlocal STRANGE_NUMBER = RAW_NUMBER:instantiate("strange_number", {\n    ["@"] = function(interpret, value)\n        if type(value) ~= "number" then\n            if value == "1" then\n                value = 1\n            else\n                typeclass.skip()\n            end\n        end\n        return value\n    end\n})\n\nprelude.map = declare({"effect", effect}, {"mapper", p.CALLABLE})\nprelude.append = declare({"effects", p.array(effect)})\n\nprelude.chain = declare(\n    {"effect", effect}, {"continuations", p.array(p.CALLABLE)})\nprelude.replicate = declare(\n    {"effect", effect}, {"count", NUMBER})\n\nreturn prelude',"@./Users/tylerling/Documents/Projects/gilatod/packages/phale-std/src/init.lua").call("./init.lua")},974:(n,e,t)=>{var r=t(911),a=r.lua,i=r.lauxlib,u=r.L,o=r.interop.push;i.luaL_getsubtable(u,a.LUA_REGISTRYINDEX,i.LUA_PRELOAD_TABLE),a.lua_pushcfunction(u,(function(n){return o(n,t(979)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.guard")),a.lua_pushcfunction(u,(function(n){return o(n,t(786)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.pattern")),a.lua_pop(u,1),n.exports=r.load('local guard = require("meido.guard")\nlocal pattern = require("meido.pattern")\n\nlocal yield = coroutine.yield\nlocal unpack = table.unpack\n\nlocal effect = {}\n\nsetmetatable(effect, {\n    __index = pattern.meta("phale.effect", effect),\n    __call = function(self, tag, ...)\n        guard.non_nil("tag", tag)\n        return setmetatable({tag, ...}, self)\n    end\n})\n\neffect.pure = function(object)\n    return effect("$pure", object)\nend\n\neffect.bind = function(eff, continuation)\n    return effect("$bind", eff, continuation)\nend\n\neffect.__concat = effect.bind\n\nfunction effect:__call(...)\n    return yield(setmetatable({...}, self));\nend\n\neffect.declare = function(...)\n    local arg_specs = {...}\n    for i = 1, #arg_specs do\n        local spec = arg_specs[i]\n        local name, pat = spec[1], spec[2]\n        if type(name) ~= "string" then\n            error(("invalid argument specification #%d: name must be string"):format(i), 2)\n        elseif type(pat) ~= "table" or not pat.match then\n            error(("invalid argument specification #%d \'%s\': pattern must have match function"):format(i, name), 2)\n        end\n    end\n    local function create_effect(...)\n        local args = {...}\n        for i = 1, #arg_specs do\n            local spec = arg_specs[i]\n            local arg = args[i]\n            local collection = {}\n            if not spec[2]:match(arg, collection) then\n                error(("invalid argument #%d \'%s\' (%s expected, got %s)"):format(i, spec[1], spec[2], type(arg)), 2)\n            end\n            local transformed = collection["@"]\n            if transformed ~= nil then\n                args[i] = transformed\n            end\n        end\n        return effect(create_effect, unpack(args))\n    end\n    return create_effect\nend\n\neffect.handle = function(eff, handler)\n    local tag = eff[1]\n    if tag == "$pure" then\n        return eff[2]\n    elseif tag == "$bind" then\n        local inner_eff, cont = eff[2], eff[3]\n        local result = handle_effect(inner_eff, handler)\n        if getmetatable(result) ~= effect then\n            return handle_effect(cont(result), handler)\n        else\n            -- inject effect handler\n            return effect.bind(result, function(inner_result)\n                return handle_effect(cont(inner_result), handler)\n            end)\n        end\n    else\n        return handler(unpack(eff)) or eff\n    end\nend\n\nreturn effect',"@./Users/tylerling/Documents/Projects/gilatod/packages/phale/src/effect.lua").call("./effect.lua")},254:(n,e,t)=>{var r=t(911),a=r.lua,i=r.lauxlib,u=r.L,o=r.interop.push;i.luaL_getsubtable(u,a.LUA_REGISTRYINDEX,i.LUA_PRELOAD_TABLE),a.lua_pushcfunction(u,(function(n){return o(n,t(979)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.guard")),a.lua_pushcfunction(u,(function(n){return o(n,t(786)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.pattern")),a.lua_pop(u,1),n.exports=r.load('local guard = require("meido.guard")\nlocal pattern = require("meido.pattern")\n\nlocal unpack = table.unpack\n\nlocal object = {}\n\nsetmetatable(object, {\n    __index = pattern.meta("phale.object", object),\n    __call = function(self, tag, ...)\n        guard.non_nil("tag", tag)\n        return setmetatable({tag, {...}}, self)\n    end\n})\n\nfunction object:__index(k)\n    local obj = object("index", self, k)\n    rawset(self, k, obj)\n    return obj\nend\n\nfunction object:__call(...)\n    return object("call", {self, ...})\nend\n\nlocal function register_uniary(mt_func, tag)\n    object[mt_func] = function(arg)\n        return object(tag, arg)\n    end\nend\n\nregister_uniary("__unm", "unm")\nregister_uniary("__len", "len")\nregister_uniary("__bnot", "bnot")\n\nlocal function register_binary(mt_func, tag)\n    object[mt_func] = function(left, right)\n        return object(tag, left, right)\n    end\nend\n\nregister_binary("__add", "add")\nregister_binary("__sub", "sub")\nregister_binary("__mul", "mul")\nregister_binary("__div", "div")\nregister_binary("__idiv", "idiv")\n\nregister_binary("__pow", "pow")\nregister_binary("__mod", "mod")\nregister_binary("__concat", "concat")\nregister_binary("__eq", "eq")\nregister_binary("__lt", "lt")\nregister_binary("__le", "le")\n\nregister_binary("__band", "band")\nregister_binary("__bor", "bor")\nregister_binary("__bxor", "bxor")\n\nregister_binary("__shl", "shl")\nregister_binary("__shr", "shr")\n\nobject.memorize = function(computation)\n    guard.callable("computation", computation)\n    local value\n    return object("memorize", function()\n        if value == nil then\n            value = computation()\n        end\n        return value\n    end)\nend\n\nobject.interpret = function(obj, interpreters)\n    local function do_interpret(obj)\n        if getmetatable(obj) ~= object then\n            local lift = interpreters["@"]\n            return lift and lift(do_interpret, obj) or obj\n        end\n\n        local tag = rawget(obj, 1)\n        local args = rawget(obj, 2)\n\n        if tag == "memorize" then\n            return do_interpret(args[1]())\n        end\n\n        local interpreter = interpreters[tag]\n        if not interpreter then\n            error("failed to interpret object with tag \'"..tag.."\'")\n        end\n        return interpreter(interpreters, do_interpret, unpack(args))\n    end\n    return do_interpret(obj)\nend\n\nreturn object',"@./Users/tylerling/Documents/Projects/gilatod/packages/phale/src/object.lua").call("./object.lua")},587:(n,e,t)=>{var r=t(911),a=r.lua,i=r.lauxlib,u=r.L,o=r.interop.push;i.luaL_getsubtable(u,a.LUA_REGISTRYINDEX,i.LUA_PRELOAD_TABLE),a.lua_pushcfunction(u,(function(n){return o(n,t(979)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.guard")),a.lua_pushcfunction(u,(function(n){return o(n,t(786)),1})),a.lua_setfield(u,-2,r.to_luastring("meido.pattern")),a.lua_pushcfunction(u,(function(n){return o(n,t(254)),1})),a.lua_setfield(u,-2,r.to_luastring("phale.object")),a.lua_pop(u,1),n.exports=r.load('local guard = require("meido.guard")\nlocal pattern = require("meido.pattern")\n\nlocal object = require("phale.object")\n\nlocal co_create = coroutine.create\nlocal co_yield = coroutine.yield\nlocal co_resume = coroutine.resume\nlocal co_status = coroutine.status\nlocal NO_DEFAULT = pattern.NO_DEFAULT\nlocal collect = pattern.collect\n\nlocal interpret = object.interpret\n\nlocal typeclass = {}\n\nsetmetatable(typeclass, {\n    __index = pattern.meta("phale.typeclass", typeclass),\n    __call = function(self, name, pats)\n        guard.string("name", name)\n\n        local parents = {}\n        local children = {}\n        local patterns = {}\n        local defaults = setmetatable({}, {\n            __index = function(t, k)\n                for i = #parents, 1, -1 do\n                    local v = parents[i].defaults[k]\n                    if v ~= nil then return v end\n                end\n            end\n        })\n\n        local instance = {\n            parents = parents,\n            children = children,\n            patterns = patterns,\n            defaults = defaults\n        }\n\n        local full = true\n        if pats then\n            guard.table("patterns", pats)\n            for key, pat in pairs(pats) do\n                local pat = pattern.from(pat)\n                if pat:has_default() then\n                    defaults[key] = pat:get_default()\n                else\n                    full = false\n                end\n                patterns[key] = pat\n            end\n        end\n        instance.full = full\n\n        instance.pattern = pattern(\n            "phale.typeclass", NO_DEFAULT,\n            function() return name end,\n            function(v, c, s)\n                for i = #children, 1, -1 do\n                    if children[i]:match(v, c, s) then\n                        return true\n                    end\n                end\n                if instance.full then\n                    local co = co_create(interpret)\n                    local succ, res = co_resume(co, v, defaults)\n                    if not succ then error(res, 0) end\n                    if co_status(co) ~= "suspended" then\n                        if c then c["@"] = res end\n                        return true\n                    end\n                end\n            end)\n\n        function instance:has_default() return false end\n        function instance:get_description() return self.pattern:get_description() end\n        function instance:match(v, c, s) return self.pattern:match(v, c, s) end\n        function instance:guard(n, v) return self.pattern:guard(n, v) end\n\n        return setmetatable(instance, self)\n    end\n})\ntypeclass.__index = typeclass\n\ntypeclass.skip = co_yield\n\nfunction typeclass:__tostring()\n    return tostring(self.pattern)\nend\n\nfunction typeclass:to_pattern()\n    return self.pattern\nend\n\nfunction typeclass:is_full()\n    return self.full\nend\n\nlocal function for_patterns(tc, f)\n    local parents = tc.parents\n    for i = 1, #parents do\n        for_patterns(parents[i], f)\n    end\n    for key, pat in pairs(tc.patterns) do\n        f(key, pat)\n    end\nend\n\nlocal function find_pattern(tc, key)\n    local pat = tc.patterns[key]\n    if pat then return pat end\n    \n    local parents = tc.parents\n    for i = 1, #parents do\n        pat = find_pattern(parents[i], key)\n        if pat then return pat end\n    end\nend\n\nlocal function update_full(tc)\n    local defaults = tc.defaults\n    tc.full = pcall(for_patterns, tc,\n        function(key, pat)\n            if not defaults[key] then error() end\n        end)\n    local children = tc.children\n    for i = 1, #children do\n        update_full(children[i])\n    end\nend\n\nfunction typeclass:instantiate(name, arguments)\n    guard.string("name", name)\n\n    local child = typeclass(name)\n    local defaults = child.defaults\n    child.parents[1] = self\n\n    if arguments then\n        guard.table("arguments", arguments)\n        for k, v in pairs(arguments) do\n            local pat = find_pattern(self, k)\n            if pat then\n                if not pat:match(v) then\n                    error(("failed to instantiate %s (%s : %s expected, got %s)")\n                        :format(self, k, pat, type(v)), 2)\n                end\n                defaults[k] = v\n            end\n        end\n    end\n\n    for_patterns(self, function(key, pat)\n        if not defaults[key] then\n            error(("failed to instantiate %s (%s : %s expected)")\n                :format(self, key, pat), 5)\n        end\n    end)\n\n    local children = self.children\n    children[#children+1] = child\n    return child\nend\n\nfunction typeclass:inherit(...)\n    local tcs = {...}\n    local parents = self.parents\n\n    for i = 1, #tcs do\n        local tc = tcs[i]\n        typeclass:guard("argument", tc)\n        parents[#parents+1] = tc\n        local children = tc.children\n        children[#children+1] = self\n    end\n\n    update_full(self)\n    return self\nend\n\nreturn typeclass',"@./Users/tylerling/Documents/Projects/gilatod/packages/phale/src/typeclass.lua").call("./typeclass.lua")}},n=>{n.O(0,[216],(()=>(620,n(n.s=620)))),n.O()}]);