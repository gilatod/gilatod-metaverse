(self.webpackChunkgilatod_app_metaverse=self.webpackChunkgilatod_app_metaverse||[]).push([[179],{620:(n,e,t)=>{var r=t(911),a=r.lua,o=r.lauxlib,l=r.L,c=r.interop.push;o.luaL_getsubtable(l,a.LUA_REGISTRYINDEX,o.LUA_PRELOAD_TABLE),a.lua_pushcfunction(l,(function(n){return c(n,t(724)),1})),a.lua_setfield(l,-2,r.to_luastring("gilatod.meido")),a.lua_pop(l,1),n.exports=r.load('local meido = require "gilatod.meido"\nlocal guard = meido.guard\nlocal meta = meido.meta\n\nlocal function load()\n    print("HELLO WORLD")\nend\n\ncoroutine.wrap(function()\n    xpcall(load, function(err)\n        print(err)\n        print(debug.traceback())\n    end)\nend)()',"@./Users/tylerling/Documents/Projects/gilatod/packages/gilatod-app-metaverse/src/bootstrap.lua").call("./bootstrap.lua")},422:(n,e,t)=>{var r=t(911);n.exports=r.load('local random = math.random\nlocal remove = table.remove\n\nlocal array = {}\n\narray.find = function(t, item)\n    for i = 1, #t do\n        if t[i] == item then\n            return i\n        end\n    end\n    return false\nend\n\narray.find_all = function(t, item)\n    local res = {}\n    for i = 1, #t do\n        if t[i] == item then\n            res[#res+1] = item\n        end\n    end\n    return res\nend\n\narray.find_for = function(t, f)\n    for i = 1, #t do\n        if f(t[i]) then\n            return i\n        end\n    end\n    return false\nend\n\narray.find_all_for = function(t, f)\n    local res = {}\n    for i = 1, #t do\n        if f(t[i]) then\n            res[#res+1] = item\n        end\n    end\n    return res\nend\n\narray.remove_item = function(t, item)\n    for i = 1, #t do\n        if t[i] == item then\n            remove(t, i)\n            return true\n        end\n    end\n    return false\nend\n\narray.remove_all_items = function(t, item)\n    local c = 0\n    local i = 1\n    while i <= #t do\n        if t[i] == item then\n            remove(t, i)\n            c = c + 1\n        else\n            i = i + 1\n        end\n    end\n    return c\nend\n\narray.remove_for = function(t, f)\n    for i = 1, #t do\n        if f(t[i]) then\n            remove(t, i)\n            return true\n        end\n    end\n    return false\nend\n\narray.remove_all_for = function(t, f)\n    local c = 0\n    local i = 1\n    while i <= #t do\n        if f(t[i]) then\n            remove(t, i)\n            c = c + 1\n        else\n            i = i + 1\n        end\n    end\n    return c\nend\n\narray.clear = function(t)\n    local count = #t\n    for i = 1, #count do\n        t[i] = nil\n    end\n    return t\nend\n\narray.equal = function(t1, t2)\n    if #t1 ~= #t2 then\n        return false\n    end\n\n    for i = 1, #t1 do\n        if t1[i] ~= t2[i] then\n            return false\n        end\n    end\n\n    return true\nend\n\narray.append = function(t1, t2)\n    local init = #t1\n    for i = 1, #t2 do\n        t1[init + i] = t2[i]\n    end\n    return t1\nend\n\narray.concat = function(ts, f)\n    f = f or array.append\n\n    local res = {}\n    for i = 1, #ts do\n        res = f(res, ts[i])\n    end\n    return res\nend\n\narray.clone = function(t)\n    local r = {}\n    for i = 1, #t do\n        r[i] = t[i]\n    end\n    return r\nend\n\narray.map = function(t, f)\n    local res = {}\n    for i = 1, #t do\n        res[i] = f(t[i])\n    end\n    return res\nend\n\narray.fold = function(initial, t, f)\n    local acc = initial\n    for i = 1, #t do\n        acc = f(acc, t[i])\n    end\n    return acc\nend\n\narray.reduce = function(t, f)\n    assert(#t ~= 0, "empty array")\n\n    local acc = t[1]\n    for i = 2, #t do\n        acc = f(acc, t[i])\n    end\n    return acc\nend\n\narray.fold_rev = function(t, initial, f)\n    local acc = initial\n    for i = #t, 1, -1 do\n        acc = f(t[i], acc)\n    end\n    return acc\nend\n\narray.reduce_rev = function(t, f)\n    assert(#t ~= 0, "empty array")\n\n    local v = t[#t]\n    for i = #t - 1, 1, -1 do\n        v = f(t[i], v)\n    end\n    return v\nend\n\narray.reverse = function(t)\n    local i, j = 1, #t\n    while i < j do\n        t[i], t[j] = t[j], t[i]\n        i = i + 1\n        j = j - 1\n    end\n    return t\nend\n\narray.shuffle = function(t)\n    local c = #t\n    for i = 1, c do\n        local j = random(1, c)\n        t[j], t[i] = t[i], t[j]\n    end\n    return t\nend\n\narray.clear = function(t)\n    for i = 1, #t do\n        t[i] = nil\n    end\n    return t\nend\n\narray.generate = function(count_or_array, f)\n    local t = {}\n\n    if type(count_or_array) == "number" then\n        for i = 1, count_or_array do\n            t[i] = f(i)\n        end\n    else\n        for i = 1, #count_or_array do\n            t[i] = f(i, count_or_array[i])\n        end\n    end\n\n    return t\nend\n\nreturn array',"@./Users/tylerling/Documents/Projects/gilatod/packages/gilatod-meido/src/array.lua").call("./array.lua")},38:(n,e,t)=>{var r=t(911),a=r.lua,o=r.lauxlib,l=r.L,c=r.interop.push;o.luaL_getsubtable(l,a.LUA_REGISTRYINDEX,o.LUA_PRELOAD_TABLE),a.lua_pushcfunction(l,(function(n){return c(n,t(93)),1})),a.lua_setfield(l,-2,r.to_luastring("guard")),a.lua_pushcfunction(l,(function(n){return c(n,t(708)),1})),a.lua_setfield(l,-2,r.to_luastring("meta")),a.lua_pop(l,1),n.exports=r.load('local guard = require("guard")\nlocal meta = require("meta")\n\nlocal coroutine_create = coroutine.create\nlocal coroutine_running = coroutine.running\nlocal coroutine_yield = coroutine.yield\nlocal coroutine_resume = coroutine.resume\n\nlocal remove = table.remove\n\nlocal async = {}\n\n-- cancellation token\n\nlocal cancellation_token = {}\ncancellation_token.__index = cancellation_token\n\nfunction cancellation_token:notify(callback)\n    guard.callable("callback", callback)\n\n    local on_cancelled = self.on_cancelled\n    on_cancelled[#on_cancelled+1] = callback\nend\n\nfunction cancellation_token:unnotify(callback)\n    guard.callable("callback", callback)\n\n    local on_cancelled = self.on_cancelled\n    for i = 1, #on_cancelled do\n        if on_cancelled[i] == callback then\n            remove(on_cancelled, i)\n            return true\n        end\n    end\n\n    return false\nend\n\nfunction cancellation_token:link_to(other_token)\n    assert(getmetatable(other_token) == cancellation_token,\n        "other_token must be cancellation token")\n\n    other_token:notify(function()\n        self:cancel()\n    end)\nend\n\nlocal function is_cancelled_false()\n    return false\nend\n\nlocal function is_cancelled_true()\n    return true\nend\n\nfunction cancellation_token:cancel()\n    if self.is_cancelled == is_cancelled_true then\n        return\n    end\n    self.is_cancelled = is_cancelled_true\n\n    local on_cancelled = self.on_cancelled\n    for i = 1, #on_cancelled do\n        on_cancelled[i]()\n        on_cancelled[i] = nil\n    end\nend\n\nlocal cancelled_token = setmetatable({\n    on_cancelled = meta.ungrowable {},\n    is_cancelled = is_cancelled_true\n}, cancellation_token)\n\nasync.cancellation_token = function(cancelled)\n    if cancelled then\n        return cancelled_token\n    end\n    local t = {\n        on_cancelled = {},\n        is_cancelled = is_cancelled_false\n    }\n    return setmetatable(t, cancellation_token)\nend\n\n-- methods\n\nlocal function current_coroutine()\n    return assert(coroutine_running(),\n        "should be run in coroutine")\nend\n\nlocal function safe_resume(co, ...)\n    local success, err =\n        coroutine_resume(co, ...)\n    if not success then\n        error(err, 0)\n    end\nend\n\nasync.current_coroutine = current_coroutine\nasync.safe_resume = safe_resume\n\nasync.spawner = function(f)\n    return function(...)\n        local co = coroutine_create(f)\n        safe_resume(co, ...)\n        return co\n    end\nend\n\nasync.run = function(f, ...)\n    local co = coroutine_create(f)\n    safe_resume(co, ...)\n    return co\nend\n\nasync.forever = function(f, ...)\n    local co = coroutine_create(function()\n        while true do\n            f()\n        end\n    end)\n    safe_resume(co, ...)\n    return co\nend\n\nasync.all = function(fs)\n    guard.table("fs", fs)\n\n    local fs_count = #fs\n    for i = 1, fs_count do\n        local f = fs[i]\n        guard.callable("element in fs", f)\n    end\n\n    local co = current_coroutine()\n    local results = {}\n    local resumed = false\n\n    for i = 1, #fs do\n        local f = fs[i]\n        local f_co = coroutine_create(function()\n            local res, err = f()\n\n            if resumed then\n                return -- ignored\n            elseif not res then\n                safe_resume(co, nil, err)\n            else\n                local count = #results + 1\n                results[count] = res\n                if count ~= fs_count then\n                    return\n                end\n                safe_resume(co, results)\n            end\n\n            resumed = true\n        end)\n        safe_resume(f_co)\n    end\n\n    return coroutine_yield()\nend\n\nasync.any = function(fs)\n    guard.table("fs", fs)\n\n    local fs_count = #fs\n    for i = 1, fs_count do\n        local f = fs[i]\n        guard.callable("element in fs", f)\n    end\n\n    local co = current_coroutine()\n    local resumed = false\n\n    for i = 1, #fs do\n        local f = fs[i]\n        local f_co = coroutine_create(function()\n            local res, err = f()\n\n            if resumed then\n                return -- ignored\n            end\n\n            safe_resume(co, res, err)\n            resuemd = true\n        end)\n        safe_resume(f_co)\n    end\n\n    return coroutine_yield()\nend\n\nreturn async',"@./Users/tylerling/Documents/Projects/gilatod/packages/gilatod-meido/src/async.lua").call("./async.lua")},19:(n,e,t)=>{var r=t(911),a=r.lua,o=r.lauxlib,l=r.L,c=r.interop.push;o.luaL_getsubtable(l,a.LUA_REGISTRYINDEX,o.LUA_PRELOAD_TABLE),a.lua_pushcfunction(l,(function(n){return c(n,t(93)),1})),a.lua_setfield(l,-2,r.to_luastring("guard")),a.lua_pushcfunction(l,(function(n){return c(n,t(422)),1})),a.lua_setfield(l,-2,r.to_luastring("array")),a.lua_pop(l,1),n.exports=r.load('local guard = require("guard")\nlocal array = require("array")\n\nlocal remove_item = array.remove_item\n\nlocal temp_cbs = setmetatable({}, {\n    __mode = "v"\n})\n\nreturn function(t, name)\n    guard.table("t", t)\n\n    local cbs_name = name.."_cbs"\n\n    t["on_"..name] = function(self, callback)\n        guard.callable("callback", callback)\n        local cbs = self[cbs_name]\n        if not cbs then\n            cbs = {}\n            self[cbs_name] = cbs\n        end\n        cbs[#cbs+1] = callback\n    end\n\n    t["unlisten_"..name] = function(self, callback)\n        local cbs = self[cbs_name]\n        if not cbs then return end\n        if remove_item(cbs, callback) then\n            if #cbs == 0 then\n                self[cbs_name] = nil\n            end\n        end\n    end\n\n    return function(sender, ...)\n        local cbs = sender[cbs_name]\n        if not cbs then return end\n\n        local len = #cbs\n        for i = 1, len do\n            temp_cbs[i] = cbs[i]\n        end\n\n        for i = 1, len do\n            temp_cbs[i](sender, ...)\n        end\n    end\nend',"@./Users/tylerling/Documents/Projects/gilatod/packages/gilatod-meido/src/event.lua").call("./event.lua")},93:(n,e,t)=>{var r=t(911),a=r.lua,o=r.lauxlib,l=r.L,c=r.interop.push;o.luaL_getsubtable(l,a.LUA_REGISTRYINDEX,o.LUA_PRELOAD_TABLE),a.lua_pushcfunction(l,(function(n){return c(n,t(202)),1})),a.lua_setfield(l,-2,r.to_luastring("object")),a.lua_pop(l,1),n.exports=r.load('local object = require("object")\n\nlocal math_type = math.type\n\nlocal guard = {}\n\nlocal __error = error\nlocal function error(...)\n    print(debug.traceback())\n    __error(...)\nend\n\nlocal function inspect(v)\n    if not guard.inspect_enabled then\n        return ""\n    end\n    return ", got "..object.show(v)\nend\n\nguard.set_inspect_enabled = function(enabled)\n    guard.inspect_enabled = enabled\nend\n\nguard.is_inspect_enabled = function()\n    return guard.inspect_enabled\nend\n\n-- relational guards\n\nguard.equal = function(name, v, other)\n    if v ~= other then\n        error(name.." is expected to be "..\n            tostring(other)..inspect(v))\n    end\nend\n\nguard.non_equal = function(name, v, other)\n    if v == other then\n        error(name.." cannot be "..\n            tostring(other))\n    end\nend\n\nguard.greater = function(name, v, comparand)\n    guard.non_nil(name, v)\n    if v <= comparand then\n        error(name.." must be greater than "..\n            comparand..inspect(v))\n    end\nend\n\nguard.greater_or_equal = function(name, v, comparand)\n    guard.non_nil(name, v)\n    if v < comparand then\n        error(name.." must be greater or equal to "..\n            comparand..inspect(v))\n    end\nend\n\nguard.less = function(name, v, comparand)\n    guard.non_nil(name, v)\n    if v >= comparand then\n        error(name.." must be less than "..\n            comparand..inspect(v))\n    end\nend\n\nguard.less_or_equal = function(name, v, comparand)\n    guard.non_nil(name, v)\n    if v > comparand then\n        error(name.." must be less or equal to "..\n            comparand..inspect(v))\n    end\nend\n\n-- type guards\n\nlocal function create_type_guard(expected_type)\n    return function(name, v)\n        local t = type(v)\n        if t ~= expected_type then\n            error(name.." must be "..expected_type..inspect(v))\n        end\n    end\nend\n\nguard.string  = create_type_guard("string")\nguard.number  = create_type_guard("number")\nguard.func    = create_type_guard("function")\nguard.table   = create_type_guard("table")\nguard.boolean = create_type_guard("boolean")\n\n-- nil guards\n\nguard.is_nil = function(name, v)\n    if v ~= nil then\n        error(name.." must be nil"..inspect(v))\n    end\nend\n\nguard.non_nil = function(name, v)\n    if v == nil then\n        error(name.." cannot be nil")\n    end\nend\n\n-- string guards\n\nguard.empty_string = function(name, v)\n    guard.string(name, v)\n    if v ~= "" then\n        error(name.." must be empty string"..inspect(v))\n    end\nend\n\nguard.nonempty_string = function(name, v)\n    guard.string(name, v)\n    if v == "" then\n        error(name.." must be non-empty string")\n    end\nend\n\n-- number guards\n\nguard.integer = function(name, v)\n    if math_type(v) ~= "integer" then\n        error(name.." must be integer"..inspect(v))\n    end\nend\n\nguard.float = function(name, v)\n    if math_type(v) ~= "float" then\n        error(name.." must be float"..inspect(v))\n    end\nend\n\nguard.zero = function(name, v)\n    guard.number(name, v)\n    if v ~= 0 then\n        error(name.." must be zero"..inspect(v))\n    end\nend\n\nguard.non_zero = function(name, v)\n    guard.number(name, v)\n    if v == 0 then\n        error(name.." must be non-zero")\n    end\nend\n\nguard.finite = function(name, v)\n    guard.number(name, v)\n    if v == math.huge then\n        error(name.." must be finite number")\n    end\nend\n\nguard.positive = function(name, v)\n    guard.number(name, v)\n    if v <= 0 then\n        error(name.." must be positive number"..inspect(v))\n    end\nend\n\nguard.zero_or_positive = function(name, v)\n    guard.number(name, v)\n    if v < 0 then\n        error(name.." must be zero or positive"..inspect(v))\n    end\nend\n\nguard.negative = function(name, v)\n    guard.number(name, v)\n    if v >= 0 then\n        error(name.." must be negative number"..inspect(v))\n    end\nend\n\nguard.zero_or_negative = function(name, v)\n    guard.number(name, v)\n    if v > 0 then\n        error(name.." must be zero or negative"..inspect(v))\n    end\nend\n\nguard.odd = function(name, v)\n    guard.number(name, v)\n    if v % 2 == 0 then\n        error(name.." must be odd number"..inspect(v))\n    end\nend\n\nguard.even = function(name, v)\n    guard.number(name, v)\n    if v % 2 == 1 then\n        error(name.." must be even number"..inspect(v))\n    end\nend\n\n-- table guards\n\nlocal function create_table_guard(raw_type, metamethod, info)\n    return function(name, v)\n        local t = type(v)\n\n        if t == raw_type then\n            return\n        elseif t == "table" then\n            local meta = getmetatable(v)\n            if meta and type(meta[metamethod]) == "function" then\n                return\n            end\n        end\n\n        error(name.." must "..info..inspect(v))\n    end\nend\n\nguard.callable   = create_table_guard("function", "__call", "be callable")\nguard.concatable = create_table_guard("string", "__concat", "be concatable")\nguard.interable  = create_table_guard("table", "__pairs", "be interable")\nguard.can_add    = create_table_guard("number", "__add", "support addition")\nguard.can_sub    = create_table_guard("number", "__sub", "support subtraction")\nguard.can_mul    = create_table_guard("number", "__mul", "support multiplication")\nguard.can_div    = create_table_guard("number", "__div", "support division")\nguard.can_mod    = create_table_guard("number", "__mod", "support modulus")\nguard.can_unm    = create_table_guard("number", "__unm", "support negation")\nguard.can_pow    = create_table_guard("number", "__pow", "support exponentiation")\nguard.can_lt     = create_table_guard("number", "__lt", "support less-than operator")\nguard.can_le     = create_table_guard("number", "__le", "support less-or-equal operator")\nguard.can_idiv   = create_table_guard("number", "__idiv", "support floor division operator")\nguard.can_band   = create_table_guard("number", "__band", "support bitwise AND operator")\nguard.can_bor    = create_table_guard("number", "__bor", "support bitwise OR operator")\nguard.can_bxor   = create_table_guard("number", "__bxor", "support bitwise XOR operator")\nguard.can_bnot   = create_table_guard("number", "__bnot", "support bitwise NOT operator")\nguard.can_shl    = create_table_guard("number", "__shl", "support bitwise left shift operator")\nguard.can_shr    = create_table_guard("number", "__shl", "support bitwise right shift operator")\n\n-- boolean guards\n\nguard.truthy = function(name, v)\n    if not v then\n        error(name.." must be truthy"..inspect(v))\n    end\nend\n\nguard.falsy = function(name, v)\n    if v then\n        error(name.." must be falsy"..inspect(v))\n    end\nend\n\nguard.is_true = function(name, v)\n    if v ~= true then\n        error(name.." must be true"..inspect(v))\n    end\nend\n\nguard.is_false = function(name, v)\n    if v ~= false then\n        error(name.." must be false"..inspect(v))\n    end\nend\n\n-- error guards\n\nguard.no_error = function(func, ...)\n    local success, err = pcall(func, ...)\n    if not success then\n        error("unexpected error: "..err)\n    end\nend\n\nguard.match_error = function(pattern, func, ...)\n    local success, err = pcall(func, ...)\n    if success then\n        error("no error")\n    end\n    assert(string.match(err, pattern), "error does not match: "..err)\nend\n\nreturn guard',"@./Users/tylerling/Documents/Projects/gilatod/packages/gilatod-meido/src/guard.lua").call("./guard.lua")},724:(n,e,t)=>{var r=t(911),a=r.lua,o=r.lauxlib,l=r.L,c=r.interop.push;o.luaL_getsubtable(l,a.LUA_REGISTRYINDEX,o.LUA_PRELOAD_TABLE),a.lua_pushcfunction(l,(function(n){return c(n,t(422)),1})),a.lua_setfield(l,-2,r.to_luastring("array")),a.lua_pushcfunction(l,(function(n){return c(n,t(38)),1})),a.lua_setfield(l,-2,r.to_luastring("async")),a.lua_pushcfunction(l,(function(n){return c(n,t(19)),1})),a.lua_setfield(l,-2,r.to_luastring("event")),a.lua_pushcfunction(l,(function(n){return c(n,t(93)),1})),a.lua_setfield(l,-2,r.to_luastring("guard")),a.lua_pushcfunction(l,(function(n){return c(n,t(708)),1})),a.lua_setfield(l,-2,r.to_luastring("meta")),a.lua_pushcfunction(l,(function(n){return c(n,t(202)),1})),a.lua_setfield(l,-2,r.to_luastring("object")),a.lua_pushcfunction(l,(function(n){return c(n,t(211)),1})),a.lua_setfield(l,-2,r.to_luastring("pattern")),a.lua_pushcfunction(l,(function(n){return c(n,t(64)),1})),a.lua_setfield(l,-2,r.to_luastring("seq")),a.lua_pushcfunction(l,(function(n){return c(n,t(644)),1})),a.lua_setfield(l,-2,r.to_luastring("spec")),a.lua_pushcfunction(l,(function(n){return c(n,t(630)),1})),a.lua_setfield(l,-2,r.to_luastring("struct")),a.lua_pop(l,1),n.exports=r.load('return {\n    array   = require "array",\n    async   = require "async",\n    event   = require "event",\n    guard   = require "guard",\n    meta    = require "meta",\n    object  = require "object",\n    pattern = require "pattern",\n    seq     = require "seq",\n    spec    = require "spec",\n    struct  = require "struct"\n}',"@./Users/tylerling/Documents/Projects/gilatod/packages/gilatod-meido/src/init.lua").call("./init.lua")},708:(n,e,t)=>{var r=t(911),a=r.lua,o=r.lauxlib,l=r.L,c=r.interop.push;o.luaL_getsubtable(l,a.LUA_REGISTRYINDEX,o.LUA_PRELOAD_TABLE),a.lua_pushcfunction(l,(function(n){return c(n,t(93)),1})),a.lua_setfield(l,-2,r.to_luastring("guard")),a.lua_pop(l,1),n.exports=r.load('local guard = require("guard")\nlocal meta = {}\n\nlocal ungrowable_meta = {\n    __metatable = "ungrowable",\n    __newindex = function()\n        error("this table is ungrowable", 2)\n    end\n}\n\nmeta.ungrowable = function(t)\n    guard.table("t", t)\n    local mt = getmetatable(t)\n    if mt == "ungrowable" then\n        return t\n    elseif mt then\n        error("table has another metatable")\n    end\n    return setmetatable(t, ungrowable_meta)\nend\n\nmeta.readonly = function(t)\n    guard.table("t", t)\n    return setmetatable({}, {\n        __metatable = "readonly",\n        __index = function(t, k)\n            return t[k]\n        end,\n        __newindex = function()\n            error("this table is read-only", 2)\n        end,\n        __pairs = function() return pairs(t) end,\n        __ipairs = function() return ipairs(t) end\n    })\nend\n\nmeta.writeonly = function(t, write)\n    guard.table("t", t)\n    guard.callable("write", write)\n    return setmetatable({}, {\n        __metatable = "writeonly",\n        __index = function()\n            error("this table is write-only", 2)\n        end,\n        __newindex = function(t, k, v)\n            write(t, k, v)\n        end\n    })\nend\n\nreturn meta',"@./Users/tylerling/Documents/Projects/gilatod/packages/gilatod-meido/src/meta.lua").call("./meta.lua")},202:(n,e,t)=>{var r=t(911);n.exports=r.load('local concat = table.concat\n\nlocal object = {}\n\nlocal control_escaps = {\n    ["\\a"] = "\\\\a",\n    ["\\b"] = "\\\\b",\n    ["\\f"] = "\\\\f",\n    ["\\v"] = "\\\\v",\n    ["\\n"] = "\\\\n",\n    ["\\r"] = "\\\\r"\n}\n\nlocal function format_string(str)\n    str = (str\n        :gsub("\\\\", "\\\\\\\\")\n        :gsub("\\"", "\\\\\\""))\n        :gsub("%c", control_escaps)\n    return "\\""..str.."\\""\nend\n\nlocal function is_identifier(str)\n    return type(str) == "string"\n        and str:match("^[_%a][_%a%d]*$")\nend\n\nobject.show = function(o, initial_indent, indent)\n    local t = type(o)\n\n    if initial_indent then\n        initial_indent = tostring(initial_indent)\n        if t == "string" then\n            return initial_indent..format_string(o)\n        elseif t ~= "table" then\n            return initial_indent..tostring(o)\n        end\n    else\n        if t == "string" then\n            return format_string(o)\n        elseif t ~= "table" then\n            return tostring(o)\n        end\n    end\n    \n    if indent then\n        indent = tostring(indent)\n    else\n        indent = "    "\n    end\n\n    local root_obj = o\n\n    -- 1. first entry of the inspected\'s value is the index.\n    -- 2. second entry is the count the table is inspected.\n    -- 3. third entry will be marked as true when count > 1 and\n    --    the content of the table has been displayed.\n    local inspected = {}\n    local curr_index = 1\n\n    local function inspect(o)\n        if type(o) ~= "table" then\n            return\n        end\n\n        local entry = inspected[o]\n        if entry then\n            entry[2] = entry[2] + 1\n            if not entry[1] then\n                entry[1] = tostring(curr_index)\n                curr_index = curr_index + 1\n            end\n            return\n        else\n            inspected[o] = {nil, 1}\n        end\n\n        for k, v in next, o do\n            inspect(k)\n            inspect(v)\n        end\n    end\n\n    inspect(root_obj)\n\n    local buffer = {}\n    local formatted_strings = {}\n\n    local function raw_show(o, curr_indent)\n        local t = type(o)\n        if t == "string" then\n            local str = formatted_strings[o]\n            if not str then\n                str = format_string(o)\n                formatted_strings[o] = str\n            end\n            buffer[#buffer+1] = str\n            return\n        elseif t ~= "table" then\n            buffer[#buffer+1] = tostring(o)\n            return\n        end\n\n        local entry = inspected[o]\n\n        -- inspected more than once\n        if entry and entry[2] > 1 then\n            buffer[#buffer+1] = "<"\n            buffer[#buffer+1] = entry[1] -- index\n            buffer[#buffer+1] = ">"\n\n            local is_shown = entry[3]\n            if is_shown then return end\n\n            entry[3] = true\n            buffer[#buffer+1] = " "\n        end\n\n        buffer[#buffer+1] = "{"\n        local field_indent = curr_indent..indent\n\n        -- array elements\n        local o_len = #o\n        for i = 1, o_len do\n            local v = o[i]\n            raw_show(v, field_indent)\n            buffer[#buffer+1] = ", "\n        end\n\n        -- map elements\n        local has_map_elem = false\n\n        for k, v in next, o do\n            if type(k) == "number" and k <= o_len then\n                goto skip\n            end\n\n            if not has_map_elem then\n                has_map_elem = true\n                buffer[#buffer+1] = "\\n"\n            end\n\n            buffer[#buffer+1] = field_indent\n\n            -- format key\n            if is_identifier(k) then\n                buffer[#buffer+1] = k\n            else\n                buffer[#buffer+1] = "["\n                raw_show(k, field_indent)\n                buffer[#buffer+1] = "]"\n            end\n\n            buffer[#buffer+1] = " = "\n\n            -- format value\n            raw_show(v, field_indent)\n\n            buffer[#buffer+1] = ",\\n"\n            ::skip::\n        end\n\n        if has_map_elem then\n            buffer[#buffer] = "\\n" -- overwrite last ",\\n"\n            buffer[#buffer+1] = curr_indent\n            buffer[#buffer+1] = "}"\n        elseif o_len > 0 then\n            buffer[#buffer] = "}" -- overwrite last ", "\n        else\n            buffer[#buffer+1] = "}"\n        end\n    end\n\n    if initial_indent then\n        buffer[1] = initial_indent\n        raw_show(root_obj, initial_indent)\n    else\n        raw_show(root_obj, "")\n    end\n    return concat(buffer)\nend\n\nobject.equal = function(a, b)\n    local comparisons = {}\n\n    local function raw_equal(a, b)\n        if a == b then\n            return true\n        end\n\n        local a_type = type(a)\n        local b_type = type(b)\n\n        if a_type ~= b_type then\n            return false\n        end\n\n        if a_type ~= "table" then\n            return false\n        end\n\n        local compared_objs = comparisons[a]\n        if not compared_objs then\n            compared_objs = {\n                -- false denotes that comparison is in progress\n                [b] = false\n            }\n            comparisons[a] = compared_objs\n        elseif compared_objs[b] == false then\n            return true\n        end\n\n        for k, va in pairs(a) do\n            local vb = b[k]\n            if vb == nil then\n                return false\n            end\n\n            if va ~= vb then\n                local va_compared_objs = comparisons[va]\n                if (not va_compared_objs\n                    or not va_compared_objs[vb])\n                    and not raw_equal(va, vb) then\n                    return false\n                end\n            end\n        end\n\n        compared_objs[b] = true\n        return true\n    end\n\n    return raw_equal(a, b)\nend\n\nobject.clone = function(o)\n    if type(object) ~= "table" then\n        return object\n    end\n\n    local obj_copies = {}\n\n    local function raw_copy(object)\n        if type(object) ~= "table" then\n            return object\n        end\n\n        local mt = getmetatable(object)\n        if type(mt) ~= "table"\n                or type(mt.__newindex) == "string" then\n            return object\n        end\n\n        local obj_copy = obj_copies[object]\n        if obj_copy then\n            return obj_copy\n        end\n\n        obj_copy = {}\n        obj_copies[object] = obj_copy\n\n        for k, v in pairs(object) do\n            obj_copy[raw_copy(k)] = raw_copy(v)\n        end\n\n        return setmetatable(obj_copy, mt)\n    end\n\n    return raw_copy(o)\nend\n\nreturn object',"@./Users/tylerling/Documents/Projects/gilatod/packages/gilatod-meido/src/object.lua").call("./object.lua")},211:(n,e,t)=>{var r=t(911),a=r.lua,o=r.lauxlib,l=r.L,c=r.interop.push;o.luaL_getsubtable(l,a.LUA_REGISTRYINDEX,o.LUA_PRELOAD_TABLE),a.lua_pushcfunction(l,(function(n){return c(n,t(93)),1})),a.lua_setfield(l,-2,r.to_luastring("guard")),a.lua_pushcfunction(l,(function(n){return c(n,t(708)),1})),a.lua_setfield(l,-2,r.to_luastring("meta")),a.lua_pushcfunction(l,(function(n){return c(n,t(202)),1})),a.lua_setfield(l,-2,r.to_luastring("object")),a.lua_pushcfunction(l,(function(n){return c(n,t(422)),1})),a.lua_setfield(l,-2,r.to_luastring("array")),a.lua_pop(l,1),n.exports=r.load('local guard = require("guard")\nlocal meta = require("meta")\nlocal object = require("object")\nlocal array = require("array")\n\nlocal clear = array.clear\nlocal ungrowable = meta.ungrowable\nlocal readonly = meta.readonly\nlocal format = string.format\nlocal concat = table.concat\nlocal insert = table.insert\nlocal math_type = math.type\n\nif math_type == nil then\n    math_type = function(n)\n        if type(n) ~= "number" then\n            return nil\n        end\n        local _, f = math.modf(n)\n        return f == 0\n            and "integer" or "float"\n    end\nend\n\nlocal EMPTY_TABLE = ungrowable {}\nlocal ID_FUNC = function(...) return ... end\n\nlocal NO_DEFAULT = ungrowable {}\nlocal FAILED_PATTERN_INDEX = ungrowable {}\n\nlocal pattern = setmetatable({}, {\n    __call = function(self, category, default, desc_func, match_func)\n        guard.nonempty_string("category", category)\n        guard.callable("desc_func", desc_func)\n        guard.callable("match_func", match_func)\n\n        local t = {\n            category = category,\n            default = default,\n            desc_func = desc_func,\n            match_func = match_func\n        }\n\n        if default == NO_DEFAULT then\n            -- override pattern:get_default\n            function t:get_default()\n                error("no default")\n            end\n        elseif not match_func(default) then\n            error("invalid default value")\n        end\n\n        return setmetatable(t, self)\n    end\n})\npattern.__index = pattern\n\nfunction pattern:has_default()\n    return self.default ~= NO_DEFAULT\nend\n\nfunction pattern:get_default()\n    return self.default\nend\n\nfunction pattern:__tostring()\n    return self.desc_func()\nend\n\nfunction pattern:get_description()\n    return self.desc_func()\nend\n\nfunction pattern:match(value, collection, stack)\n    if stack then\n        stack[#stack+1] = {self, value}\n        local res = self.match_func(value, collection, stack)\n        if res then stack[#stack] = nil end\n        return res\n    else\n        return self.match_func(value, collection)\n    end\nend\n\n-- basic patterns\n\nlocal function basic_pattern(type_name, default)\n    return pattern("basic", default,\n        function() return type_name end,\n        function(v) return type(v) == type_name end)\nend\n\npattern.NIL      = basic_pattern("nil", nil)\npattern.STRING   = basic_pattern("string", "")\npattern.NUMBER   = basic_pattern("number", 0)\npattern.TABLE    = basic_pattern("table", EMPTY_TABLE)\npattern.FUNCTION = basic_pattern("function", ID_FUNC)\npattern.BOOLEAN  = basic_pattern("boolean", false)\n\npattern.ANY = pattern("basic", nil,\n    function() return "any" end,\n    function(v) return true end)\n\npattern.VOID = pattern("basic", NO_DEFAULT,\n    function() return "void" end,\n    function(v) return false end)\n\npattern.NON_NIL = pattern("basic", false,\n    function() return "non_nil" end,\n    function(v) return v ~= nil end)\n\npattern.TRUTHY = pattern("basic", true,\n    function() return "truthy" end,\n    function(v) return v end)\n\npattern.FALSY = pattern("basic", false,\n    function() return "falsy" end,\n    function(v) return not v end)\n\npattern.value = function(value)\n    local pat = pattern("value", value,\n        function()\n            if type(value) == "string" then\n                return format("\\"%s\\"", value)\n            else\n                return tostring(value)\n            end\n        end,\n        function(v)\n            return v == value\n        end)\n\n    function pat:get_value()\n        return value\n    end\n\n    return pat\nend\n\npattern.collect = function(index)\n    local pat = pattern("collect", NO_DEFAULT,\n        function() return "@"..tostring(index) end,\n        function(v, c)\n            if type(c) == "table" then\n                c[index] = v\n            end\n            return true\n        end)\n    \n    function pat:get_index()\n        return index\n    end\n\n    return pat\nend\n\n-- combinators\n\npattern.no_default = function(pat)\n    assert(getmetatable(pat) == pattern,\n        "invalid pattern")\n\n    local new_pat = pattern("no_default", NO_DEFAULT,\n        function() return format("no_default[%s]", pat) end,\n        function(v, c, s) return pat:match(v, c, s) end)\n    \n    function new_pat:get_raw_pattern()\n        return pat\n    end\n\n    return new_pat\nend\n\npattern.with_default = function(pat, default)\n    assert(getmetatable(pat) == pattern,\n        "invalid pattern")\n    assert(pat:match(default),\n        "invalid default value")\n\n    local new_pat = pattern("with_default", default,\n        function()\n            return format("with_default[%s, %s]",\n                pat, default)\n        end,\n        function(v, c, s) return pat:match(v, c, s) end)\n    \n    function new_pat:get_raw_pattern()\n        return pat\n    end\n\n    return new_pat\nend\n\npattern.named = function(name, pat)\n    guard.nonempty_string("name", name)\n    assert(getmetatable(pat) == pattern,\n        "invalid pattern")\n    \n    local new_pat = pattern("named", pat.default,\n        function() return name end,\n        function(v, c, s) return pat:match(v, c, s) end)\n    \n    function new_pat:get_raw_pattern()\n        return pat\n    end\n\n    return new_pat\nend\n\npattern.union = function(...)\n    local subpats = {...}\n    if #subpats == 0 then\n        error("no subpattern provided")\n    end\n\n    for i = 1, #subpats do\n        local subpat = subpats[i]\n        if getmetatable(subpat) ~= pattern then\n            error("invalid subpattern at index #"..i)\n        end\n    end\n\n    local default = NO_DEFAULT\n\n    for i = 1, #subpats do\n        local subpat = subpats[i]\n        if subpat:has_default() then\n            default = subpat:get_default()\n            break\n        end\n    end\n\n    local pat = pattern(\n        "union", default,\n        function()\n            local res = {}\n            for i = 1, #subpats do\n                res[#res+1] = subpats[i]:get_description()\n                res[#res+1] = " | "\n            end\n            res[#res] = nil\n            return concat(res)\n        end,\n        function(v, c, s)\n            for i = 1, #subpats do\n                if subpats[i]:match(v, c, s) then\n                    return true\n                end\n            end\n            return false\n        end)\n    \n    function pat:get_subpatterns()\n        return readonly(subpats)\n    end\n\n    return pat\nend\n\npattern.intersect = function(...)\n    local subpats = {...}\n    if #subpats == 0 then\n        error("no subpattern provided")\n    end\n\n    for i = 1, #subpats do\n        local subpat = subpats[i]\n        if getmetatable(subpat) ~= pattern then\n            error("invalid subpattern at index #"..i)\n        end\n    end\n\n    local default\n    \n    for i = 1, #subpats do\n        default = subpats[i].default\n        if default == NO_DEFAULT then\n            goto skip\n        end\n        for j = 1, #subpats do\n            if i ~= j\n                and not subpats[j]:match(default) then\n                default = NO_DEFAULT\n                break\n            end\n        end\n        ::skip::\n    end\n    \n    local pat = pattern(\n        "intersect", default,\n        function()\n            local res = {}\n            for i = 1, #subpats do\n                res[#res+1] = subpats[i]:get_description()\n                res[#res+1] = " & "\n            end\n            res[#res] = nil\n            return concat(res)\n        end,\n        function(v, c, s)\n            for i = 1, #subpats do\n                if not subpats[i]:match(v, c, s) then\n                    return false\n                end\n            end\n            return true\n        end)\n    \n    function pat:get_subpatterns()\n        return readonly(subpats)\n    end\n\n    return pat\nend\n\npattern.recurse = function(name, pattern_creator)\n    guard.nonempty_string("name", name)\n    guard.callable("pattern_creator", pattern_creator)\n\n    local pat\n\n    local hook_pat = pattern("recursion", NO_DEFAULT,\n        function() return name end,\n        function(v, c, s)\n            return pat:match(v, c, s)\n        end)\n\n    pat = pattern_creator(hook_pat)\n    assert(getmetatable(pat) == pattern,\n        "invalid pattern creator")\n\n    return pattern("recurse", pat.default,\n        function() return format("%s : %s", name, pat) end,\n        function(v, c, s)\n            return pat:match(v, c, s)\n        end)\nend\n\n-- nilable patterns\n\nlocal function basic_nilable(type_name)\n    return pattern("nilable", nil,\n        function() return type_name.."?" end,\n        function(v) return v == nil or type(v) == type_name end)\nend\n\npattern.STRING_OR_NIL   = basic_nilable("string")\npattern.NUMBER_OR_NIL   = basic_nilable("number")\npattern.TABLE_OR_NIL    = basic_nilable("table")\npattern.FUNCTION_OR_NIL = basic_nilable("function")\npattern.BOOLEAN_OR_NIL  = basic_nilable("boolean")\n\npattern.nilable = function(pat)\n    assert(getmetatable(pat) == pattern,\n        "invalid pattern")\n    \n    local new_pat = pattern("nilable", nil,\n        function() return format("nilable[%s]", pat) end,\n        function(v, c, s) return v == nil or pat:match(v, c, s) end)\n    \n    function new_pat:get_raw_pattern()\n        return pat\n    end\n\n    return new_pat\nend\n\n-- numeric patterns\n\npattern.NONNEGATIVE_NUMBER = pattern("numeric", 0,\n    function() return "nonnegative_number" end,\n    function(v) return type(v) == "number" and v >= 0 end)\n\npattern.NONPOSITIVE_NUMBER = pattern("numeric", 0,\n    function() return "nonpositive_number" end,\n    function(v) return type(v) == "number" and v <= 0 end)\n\npattern.NORMALIZED_NUMBER = pattern("numeric", 0,\n    function() return "normalized_number" end,\n    function(v) return type(v) == "number" and v >= 0 and v <= 1 end)\n\npattern.INTEGER = pattern("numeric", 0,\n    function() return "integer" end,\n    function(v) return math_type(v) == "integer" end)\n\npattern.INTEGER_OR_NIL = pattern("numeric", nil,\n    function() return "integer?" end,\n    function(v) return v == nil or math_type(v) == "integer" end)\n\npattern.POSITIVE_INTEGER = pattern("numeric", 1,\n    function() return "positive_integer" end,\n    function(v) return math_type(v) == "integer" and v > 0 end)\n\npattern.NONPOSITIVE_INTEGER = pattern("numeric", 0,\n    function() return "nonpositive_integer" end,\n    function(v) return math_type(v) == "integer" and v <= 0 end)\n\npattern.NEGATIVE_INTEGER = pattern("numeric", -1,\n    function() return "negative_integer" end,\n    function(v) return math_type(v) == "integer" and v < 0 end)\n\npattern.NONNEGATIVE_INTEGER = pattern("numeric", 0,\n    function() return "nonnegative_integer" end,\n    function(v) return math_type(v) == "integer" and v >= 0 end)\n\npattern.EVEN_INTEGER = pattern("numeric", 0,\n    function() return "even_integer" end,\n    function(v) return v % 2 == 0 end)\n\npattern.ODD_INTEGER = pattern("numeric", 1,\n    function() return "odd_integer" end,\n    function(v) return v % 2 == 1 end)\n\npattern.POSITIVE_EVEN_INTEGER = pattern("numeric", 2,\n    function() return "positive_even_integer" end,\n    function(v) return v > 0 and v % 2 == 0 end)\n\npattern.POSITIVE_ODD_INTEGER = pattern("numeric", 1,\n    function() return "positive_odd_integer" end,\n    function(v) return v > 0 and v % 2 == 1 end)\n\npattern.NEGATIVE_EVEN_INTEGER = pattern("numeric", -2,\n    function() return "negative_even_integer" end,\n    function(v) return v < 0 and v % 2 == 0 end)\n\npattern.NEGATIVE_ODD_INTEGER = pattern("numeric", -1,\n    function() return "negative_odd_integer" end,\n    function(v) return v < 0 and v % 2 == 1 end)\n\npattern.NONNEGATIVE_EVEN_INTEGER = pattern("numeric", 0,\n    function() return "nonnegative_even_integer" end,\n    function(v) return v >= 0 and v % 2 == 0 end)\n\npattern.range = function(min_value, max_value)\n    guard.non_nil("min_value", min_value)\n    guard.non_nil("max_value", max_value)\n\n    local pat = pattern("range", min_value,\n        function()\n            return format("[%s ~ %s]", min_value, max_value)\n        end,\n        function(v, c)\n            local succ, res = pcall(function()\n                return min_value <= v and v <= max_value\n            end)\n            return succ, res\n        end)\n\n    function pat:get_min()\n        return min_value\n    end\n\n    function pat:get_max()\n        return max_value\n    end\n\n    return pat\nend\n\n-- string patterns\n\npattern.NONEMPTY_STRING = pattern("string", "NIL",\n    function() return "nonempty_string" end,\n    function(v) return type(v) == "string" and #v > 0 end)\n\npattern.regex = function(regex)\n    guard.string("regex", regex)\n\n    local pat = pattern("string", "",\n        function()\n            return format("/%s/", regex)\n        end,\n        function(v)\n            return type(v) == "string" and find(regex, v)\n        end)\n    \n    function pat:get_regex()\n        return regex\n    end\n\n    return pat\nend\n\n-- callable patterns\n\npattern.CALLABLE = pattern("callable", ID_FUNC,\n    function() return "callable" end,\n    function(v)\n        if type(v) == "function" then\n            return true\n        end\n        local mt = getmetatable(v)\n        return type(mt) == "table" and mt.__call\n    end)\n\npattern.CALLABLE_OR_NIL = pattern("callable", nil,\n    function() return "callable?" end,\n    function(v)\n        if not v or type(v) == "function" then\n            return true\n        end\n        local mt = getmetatable(v)\n        return type(mt) == "table" and mt.__call\n    end)\n\n-- meta patterns\n\npattern.meta = function(name, metatable)\n    guard.nonempty_string("name", name)\n    guard.table("metatable", metatable)\n\n    local pat = pattern("meta", nil,\n        function()\n            return "%"..name\n        end,\n        function(v)\n            return v == nil or getmetatable(v) == metatable\n        end)\n    \n    function pat:get_metatable()\n        return metatable\n    end\n\n    return pat\nend\n\n-- enum patterns\n\npattern.enum = function(items)\n    guard.table("items", items)\n\n    local item_arr = {}\n    local item_map = {}\n\n    for i = 1, #items do\n        local item = items[i]\n        if item_map[item] then\n            error("duplicate item found: "..tostring(item))\n        end\n        item_arr[i] = item\n        item_map[item] = i\n    end\n\n    local pat = pattern("enum", items[1],\n        function()\n            local res = {"("}\n            for i = 1, #item_arr do\n                local item = item_arr[i]\n                if type(item) == "string" then\n                    res[#res+1] = "\\""\n                    res[#res+1] = item\n                    res[#res+1] = "\\""\n                else\n                    res[#res+1] = tostring(item)\n                end\n                res[#res+1] = " | "\n            end\n            res[#res] = ")"\n            return concat(res)\n        end,\n        function(v)\n            return item_map[v]\n        end)\n    \n    function pat:get_items()\n        return readonly(item_arr)\n    end\n\n    return pat\nend\n\n-- table patterns\n\npattern.array = function(element_pattern)\n    assert(getmetatable(element_pattern) == pattern,\n        "invalid element_pattern")\n    \n    local pat = pattern("array", EMPTY_TABLE,\n        function()\n            return format("{%s}",\n                element_pattern:get_description())\n        end,\n        function(v, c, s)\n            if type(v) ~= "table" then\n                return false\n            end\n            for i = 1, #v do\n                if not element_pattern:match(v[i], c, s) then\n                    return false\n                end\n            end\n            return true\n        end)\n    \n    function pat:get_element_pattern()\n        return element_pattern\n    end\n\n    return pat\nend\n\npattern.map = function(key_pattern, value_pattern)\n    assert(getmetatable(key_pattern) == pattern,\n        "invalid key_pattern")\n    assert(getmetatable(value_pattern) == pattern,\n        "invalid value_pattern")\n    \n    local pat = pattern("map", EMPTY_TABLE,\n        function()\n            return format("{%s => %s}",\n                key_pattern:get_description(),\n                value_pattern:get_description())\n        end,\n        function(v, c, s)\n            if type(v) ~= "table" then\n                return false\n            end\n            for key, value in pairs(v) do\n                if not key_pattern:match(key, c, s)\n                    or not value_pattern:match(value, c, s) then\n                    return false\n                end\n            end\n            return true\n        end)\n    \n    function pat:get_key_pattern()\n        return key_pattern\n    end\n\n    function pat:get_value_pattern()\n        return value_pattern\n    end\n\n    return pat\nend\n\npattern.tuple = function(...)\n    local subpats = {...}\n    if #subpats == 0 then\n        error("no subpattern provided")\n    end\n\n    local default\n\n    for i = 1, #subpats do\n        local subpat = subpats[i]\n        if getmetatable(subpat) ~= pattern then\n            error("invalid subpattern at index #"..i)\n        end\n        if not subpat:has_default() then\n            default = NO_DEFAULT\n        end\n    end\n\n    if default ~= NO_DEFAULT then\n        default = {}\n        for i = 1, #subpats do\n            default[i] = subpats[i]:get_default()\n        end\n    end\n\n    local pat = pattern("tuple", default,\n        function()\n            local res = {"("}\n            for i = 1, #subpats do\n                res[#res+1] = subpats[i]:get_description()\n                res[#res+1] = ", "\n            end\n            res[#res] = ")"\n            return concat(res)\n        end,\n        function(v, c, s)\n            if type(v) ~= "table" then\n                return false\n            end\n            for i = 1, #subpats do\n                if not subpats[i]:match(v[i], c, s) then\n                    return false\n                end\n            end\n            return true\n        end)\n    \n    function pat:get_subpatterns()\n        return readnoly(subpats)\n    end\n\n    return pat\nend\n\npattern.table = function(entries)\n    guard.table("entries", entries)\n    \n    local entries_cpy = {}\n    local default\n\n    for key, value_pat in pairs(entries) do\n        if getmetatable(value_pat) ~= pattern then\n            error("invalid entry at index #"..i)\n        end\n\n        entries_cpy[key] = value_pat\n\n        if not value_pat:has_default() then\n            default = NO_DEFAULT\n        end\n    end\n\n    if default ~= NO_DEFAULT then\n        default = {}\n        for key, value_pat in pairs(entries) do\n            default[key] = value_pat:get_default()\n        end\n    end\n\n    local pat = pattern("table", default,\n        function()\n            local res = {"{"}\n            for key, value_pat in pairs(entries_cpy) do\n                res[#res+1] = tostring(key)\n                res[#res+1] = " = "\n                res[#res+1] = value_pat:get_description()\n                res[#res+1] = ", "\n            end\n            res[#res] = "}"\n            return concat(res)\n        end,\n        function(v, c, s)\n            if type(v) ~= "table" then\n                return false\n            end\n\n            for key, value_pat in pairs(entries_cpy) do\n                local value = v[key]\n                if not value_pat:match(value, c, s) then\n                    print(key, value)\n                    return false\n                end\n            end\n            return true\n        end)\n    \n    function pat:get_entries()\n        return readonly(entries_cpy)\n    end\n\n    return pat\nend\n\npattern.loop = function(...)\n    local subpats = {...}\n    if #subpats == 0 then\n        error("no subpattern provided")\n    end\n\n    for i = 1, #subpats do\n        local subpat = subpats[i]\n        if getmetatable(subpat) ~= pattern then\n            error("invalid subpattern at index #"..i)\n        end\n        if subpat:match(nil) then\n            error("pattern that matches nil cannot be used in loop")\n        end\n    end\n\n    local pat = pattern("loop", EMPTY_TABLE,\n        function()\n            local res = {"loop {"}\n            for i = 1, #subpats do\n                res[#res+1] = subpats[i]:get_description()\n                res[#res+1] = ", "\n            end\n            res[#res] = "}"\n            return concat(res)\n        end,\n        function(v, c, s)\n            if type(v) ~= "table" then\n                return false\n            end\n            local i = 1\n            while i <= #v do\n                for j = 1, #subpats do\n                    local subpat = subpats[j]\n                    if not subpat:match(v[i], c, s) then\n                        return false\n                    end\n                    i = i + 1\n                end\n            end\n            return true\n        end)\n    \n    function pat:get_subpatterns()\n        return readonly(subpats)\n    end\n\n    return pat\nend\n\nreturn pattern',"@./Users/tylerling/Documents/Projects/gilatod/packages/gilatod-meido/src/pattern.lua").call("./pattern.lua")},64:(n,e,t)=>{var r=t(911),a=r.lua,o=r.lauxlib,l=r.L,c=r.interop.push;o.luaL_getsubtable(l,a.LUA_REGISTRYINDEX,o.LUA_PRELOAD_TABLE),a.lua_pushcfunction(l,(function(n){return c(n,t(93)),1})),a.lua_setfield(l,-2,r.to_luastring("guard")),a.lua_pop(l,1),n.exports=r.load('local guard = require "guard"\n\nlocal random = math.random\nlocal char = string.char\nlocal concat = table.concat\nlocal unpack = table.unpack\nlocal mininteger = math.mininteger\nlocal maxinteger = math.maxinteger\n\nlocal seq = {}\nseq.__index = seq\n\nsetmetatable(seq, {\n    __call = function(_, t)\n        return seq.array_values(t)\n    end\n})\n\nlocal function new(iter_gen)\n    local t = {iter = iter_gen}\n    return setmetatable(t, seq)\nend\n\nlocal function new_simple(iter)\n    local t = {\n        iter = function()\n            return iter\n        end\n    }\n    return setmetatable(t, seq)\nend\n\n-- methods\n\nfunction seq:to_array(count)\n    local res = {}\n\n    if count then\n        guard.number("count", count)\n\n        local curr = 1\n        for v in self:iter() do\n            if curr > count then\n                break\n            end\n            res[#res+1] = v\n            curr = curr + 1\n        end\n    else\n        for v in self:iter() do\n            res[#res+1] = v\n        end\n    end\n\n    return res\nend\n\nfunction seq:first()\n    local iter = self:iter()\n    return iter()\nend\n\nfunction seq:last()\n    local res\n    local iter = self:iter()\n\n    while true do\n        local new_res = iter()\n        if new_res == nil then\n            return res\n        end\n        res = new_res\n    end\nend\n\nlocal function raw_fold(iter, acc, f)\n    while true do\n        local v = iter()\n        if v == nil then\n            return acc\n        end\n        acc = f(acc, v)\n    end\nend\n\nfunction seq:fold(initial, f)\n    guard.callable("f", f)\n\n    local iter = self:iter()\n    return raw_fold(iter, initial, f)\nend\n\nfunction seq:reduce(f)\n    guard.callable("f", f)\n\n    local iter = self:iter()\n    local initial = iter()\n\n    if initial == nil then\n        error("empty sequence")\n    end\n\n    return raw_fold(iter, initial, f)\nend\n\nfunction seq:map(f)\n    guard.callable("f", f)\n\n    return new(function()\n        local iter = self:iter()\n        return function()\n            local v = iter()\n            if v == nil then return nil end\n            return f(v)\n        end\n    end)\nend\n\nfunction seq:concat()\n    return new(function()\n        local iter = self:iter()\n        local curr_seq_iter\n\n        return function()\n            local res\n\n            while true do\n                if curr_seq_iter then\n                    res = curr_seq_iter()\n                    if res ~= nil then break end\n                end\n                local curr_seq = iter()\n                if curr_seq == nil then\n                    return nil\n                end\n                curr_seq_iter = curr_seq:iter()\n            end\n\n            return res\n        end\n    end)\nend\n\nfunction seq:flat_map(f)\n    guard.callable("f", f)\n\n    return new(function()\n        local iter = self:iter()\n        local curr_seq_iter\n\n        return function()\n            local res\n\n            while true do\n                if curr_seq_iter then\n                    res = curr_seq_iter()\n                    if res ~= nil then break end\n                end\n                local curr_seq = iter()\n                if curr_seq == nil then\n                    return nil\n                end\n                curr_seq_iter = curr_seq:iter()\n            end\n\n            return f(res)\n        end\n    end)\nend\n\nfunction seq:take(count)\n    guard.number("count", count)\n\n    return new(function()\n        local iter = self:iter()\n        local curr = 1\n\n        return function()\n            if curr > count then\n                return nil\n            end\n            curr = curr + 1\n            return iter()\n        end\n    end)\nend\n\nfunction seq:drop(count)\n    guard.number("count", count)\n\n    return new(function()\n        local iter = self:iter()\n\n        for i = 1, count do\n            if iter() == nil then\n                break\n            end\n        end\n\n        return iter\n    end)\nend\n\nlocal function raw_scan(iter, acc, f)\n    return function()\n        local v = iter()\n        if v == nil then return nil end\n        acc = f(acc, v)\n        return acc\n    end\nend\n\nfunction seq:scan(initial, f)\n    guard.callable("f", f)\n\n    return new(function()\n        local iter = self:iter()\n        return raw_scan(iter, initial, f)\n    end)\nend\n\nfunction seq:scan1(f)\n    guard.callable("f", f)\n\n    return new(function()\n        local iter = self:iter()\n\n        local initial = iter()\n        if initial == nil then\n            error("empty sequence")\n        end\n\n        return raw_scan(iter, initial, f)\n    end)\nend\n\nseq.combine = function(seqs, combiner)\n    guard.table("seqs", seqs)\n    if #seqs < 2 then\n        error("at least 2 sequences are required")\n    end\n    for i = 1, #seqs do\n        guard.callable("sequence:iter", seqs[i].iter)\n    end\n\n    if combiner then\n        guard.callable("combiner", combiner)\n    else\n        combiner = function(...)\n            return {...}\n        end\n    end\n\n    if #seqs == 2 then\n        local seq1 = seqs[1]\n        local seq2 = seqs[2]\n        return new(function()\n            local iter1 = seq1:iter()\n            local iter2 = seq2:iter()\n            return function()\n                local res1 = iter1()\n                if res1 == nil then return nil end\n                local res2 = iter2()\n                if res2 == nil then return nil end\n                return combiner(res1, res2)\n            end\n        end)\n    elseif #seqs == 3 then\n        local seq1 = seqs[1]\n        local seq2 = seqs[2]\n        local seq3 = seqs[3]\n        return new(function()\n            local iter1 = seq1:iter()\n            local iter2 = seq2:iter()\n            local iter3 = seq3:iter()\n            return function()\n                local res1 = iter1()\n                if res1 == nil then return nil end\n                local res2 = iter2()\n                if res2 == nil then return nil end\n                local res3 = iter3()\n                if res3 == nil then return nil end\n                return combiner(res1, res2, res3)\n            end\n        end)\n    else\n        return new(function()\n            local cache = {}\n            local iters = {}\n            for i = 1, #seqs do\n                iters[i] = seqs[i]:iter()\n            end\n            return function()\n                for i = 1, #iters do\n                    local res = iters[i]()\n                    if res == nil then\n                        return nil\n                    end\n                    cache[i] = res\n                end\n                return combiner(unpack(cache))\n            end\n        end)\n    end\nend\n\n-- creators\n\nlocal none_seq = new(function()\n    return function()\n        return nil\n    end\nend)\n\nseq.none = function()\n    return none_seq\nend\n\nseq.single = function(v)\n    return new(function()\n        local produced\n        return function()\n            if produced then\n                return nil\n            end\n            produced = true\n            return v\n        end\n    end)\nend\n\nseq.replicate = function(v, count)\n    if not count then\n        local iter = function()\n            return v\n        end\n        return new(function()\n            return iter\n        end)\n    end\n\n    return new(function()\n        local curr = 1\n        return function()\n            if curr > count then\n                return nil\n            end\n            curr = curr + 1\n            return v\n        end\n    end)\nend\n\nseq.generate = function(f_or_initial, f)\n    if f then\n        guard.callable("f", f)\n\n        local initial = f_or_initial\n        return new(function()\n            local v = initial\n            return function()\n                v = f(v)\n                return v\n            end\n        end)\n    else\n        f = f_or_initial\n        guard.callable("f", f)\n\n        return new(function()\n            return f\n        end)\n    end\nend\n\nseq.pairs = function(t)\n    guard.table("t", t)\n\n    return new(function()\n        local finished, k, v\n        return function()\n            if finished then return nil end\n\n            k, v = next(t, k)\n            if not k then\n                finished = true\n                return nil\n            end\n            return {k, v}\n        end\n    end)\nend\n\nseq.keys = function(t)\n    guard.table("t", t)\n\n    return new(function()\n        local finished, k\n        return function()\n            if finished then return nil end\n\n            k = next(t, k)\n            if not k then\n                finished = true\n                return nil\n            end\n            return k\n        end\n    end)\nend\n\nseq.values = function(t)\n    guard.table("t", t)\n\n    return new(function()\n        local finished, k, v\n        return function()\n            if finished then return nil end\n\n            k, v = next(t, k)\n            if not k then\n                finished = true\n                return nil\n            end\n            return v\n        end\n    end)\nend\n\nseq.array_values = function(t)\n    guard.table("t", t)\n\n    return new(function()\n        local i = 0\n        return function()\n            if i >= #t then\n                return nil\n            end\n            i = i + 1\n            return t[i]\n        end\n    end)\nend\n\nseq.indices = function()\n    return new(function()\n        local i = 0\n        return function()\n            i = i + 1\n            return i\n        end\n    end)\nend\n\nseq.random = function(t)\n    guard.table("t", t)\n\n    local iter = function()\n        return t[random(1, #t)]\n    end\n\n    return new(function() return iter end)\nend\n\nseq.range = function(from, to, step)\n    guard.can_add("from", from)\n    guard.can_lt("from", from)\n\n    step = step or 1\n    guard.can_lt("step", step)\n\n    if step > 0 then\n        return new(function()\n            local curr = from\n            return function()\n                if curr > to then\n                    return nil\n                end\n\n                local res = curr\n                curr = curr + step\n                return res\n            end\n        end)\n    else\n        return new(function()\n            local curr = from\n            return function()\n                if curr < to then\n                    return nil\n                end\n\n                local res = curr\n                curr = curr + step\n                return res\n            end\n        end)\n    end\nend\n\nlocal simple_number_seq = new_simple(function()\n    return random()\nend)\n\nseq.numbers = function(min, max)\n    if not min and not max then\n        return simple_number_seq\n    end\n\n    guard.number("min", min)\n    guard.number("max", max)\n\n    local diff = max - diff\n    local iter = function()\n        return min + random(diff) * diff\n    end\n\n    return new(function() return iter end)\nend\n\nlocal half_min = math.floor(mininteger / 2)\nlocal half_max = math.floor(maxinteger / 2) - 1\nlocal simple_integer_seq = new_simple(function()\n    return random(half_min, half_max)\nend)\n\nseq.integers = function(min, max)\n    if not min and not max then\n        return simple_integer_seq\n    end\n\n    guard.integer("min", min)\n    guard.integer("max", max)\n\n    local iter = function()\n        return random(min, max)\n    end\n\n    return new(function() return iter end)\nend\n\nlocal pos_integer_seq = new_simple(function()\n    return random(1, maxinteger)\nend)\n\nlocal neg_integer_seq = new_simple(function()\n    return random(mininteger, -1)\nend)\n\nseq.positive_integers = function()\n    return pos_integer_seq\nend\n\nseq.negative_integers = function()\n    return neg_integer_seq\nend\n\nseq.strings = function(\n    min_len, max_len, chars_or_min_byte, max_byte)\n    guard.number("min_len", min_len)\n    guard.number("max_len", max_len)\n\n    chars_or_min_byte = chars_or_min_byte or 33\n    max_byte = max_byte or 126\n\n    local iter\n\n    local t = type(chars_or_min_byte) \n    local buffer = {}\n\n    if t == "string" then\n        local chars = chars_or_min_byte\n        local chars_len = #chars\n        iter = function()\n            local len = random(min_len, max_len)\n            for i = 1, len do\n                local pos = random(1, chars_len)\n                buffer[i] = chars:byte(pos)\n            end\n            for i = len + 1, #buffer do\n                buffer[i] = nil\n            end\n            return char(unpack(buffer))\n        end\n    elseif t == "number" then\n        local min_byte = chars_or_min_byte\n        guard.number("max_byte", max_byte)\n\n        iter = function()\n            local len = random(min_len, max_len)\n            for i = 1, len do\n                buffer[i] = random(min_byte, max_byte)\n            end\n            for i = len + 1, #buffer do\n                buffer[i] = nil\n            end\n            return char(unpack(buffer))\n        end\n    else\n        error("argument #3 must be string or number")\n    end\n\n    return new(function() return iter end)\nend\n\nreturn seq',"@./Users/tylerling/Documents/Projects/gilatod/packages/gilatod-meido/src/seq.lua").call("./seq.lua")},644:(n,e,t)=>{var r=t(911),a=r.lua,o=r.lauxlib,l=r.L,c=r.interop.push;o.luaL_getsubtable(l,a.LUA_REGISTRYINDEX,o.LUA_PRELOAD_TABLE),a.lua_pushcfunction(l,(function(n){return c(n,t(93)),1})),a.lua_setfield(l,-2,r.to_luastring("guard")),a.lua_pushcfunction(l,(function(n){return c(n,t(202)),1})),a.lua_setfield(l,-2,r.to_luastring("object")),a.lua_pop(l,1),n.exports=r.load('local guard = require("guard")\nlocal object = require("object")\n\nlocal show = object.show\nlocal clone = object.clone\nlocal equal = object.equal\n\nlocal concat = table.concat\nlocal gsub = string.gsub\n\nlocal spec = {\n    max_argument_count = 32\n}\n\nspec.get_max_argument_count = function()\n    return spec.max_argument_count\nend\n\nspec.set_max_argument_count = function(count)\n    spec.max_argument_count = count\nend\n\n-- auxiliary functions\n\nlocal function require_description(config)\n    local description = config.description\n    guard.nonempty_string("config.description", description)\n    return description\nend\n\nlocal function require_method(config, name)\n    local method = config[name]\n    guard.callable("config."..name, method)\n    return method\nend\n\nlocal function require_methods(config, name)\n    local methods = config[name]\n\n    local print_name = "config."..name\n    guard.table(print_name, methods)\n\n    local elem_print_name = "elements in "..print_name\n    for _, method in pairs(methods) do\n        guard.callable(elem_print_name, method)\n    end\n\n    return methods\nend\n\nlocal function require_check_equal(config)\n    local check_equal = config.check_equal\n    if check_equal then\n        guard.callable("config.check_equal", check_equal)\n    else\n        -- use object.equal\n        check_equal = equal\n    end\n    return check_equal\nend\n\nlocal function require_arguments(config)\n    local arguments = config.arguments\n    if not arguments then\n        return nil\n    end\n    guard.table("config.arguments", arguments)\n    guard.callable("config.arguments:iter", arguments.iter)\n    return arguments\nend\n\nlocal function format(obj)\n    local res = gsub(show(obj, "\\t"), "^%s", "")\n    return res\nend\n\nlocal function format_err(err)\n    local res = "[error] "..gsub(err, "([\\r\\n]+)", "%1\\t")\n    return res\nend\n\nlocal function format_res(res, success)\n    if success then\n        return format(res)\n    else\n        return format_err(res)\n    end\nend\n\nlocal function foreach_arg(self, arguments, f)\n    if not arguments then\n        arguments = self.arguments\n        if not arguments then\n            error("arguments not provided")\n        end\n    else\n        guard.table("arguments", arguments)\n    end\n\n    local count = 1\n    local max_argument_count = spec.max_argument_count\n\n    for arg in pairs(arguments) do\n        if count > max_argument_count then\n            return\n        end\n        f(arg)\n        count = count + 1\n    end\nend\n\nlocal function err(info)\n    error(concat(info), 0)\nend\n\n-- satisfy spec\n\nlocal satisfy_spec = {}\nsatisfy_spec.__index = satisfy_spec\n\nfunction satisfy_spec:get_description()\n    return self.description\nend\n\nfunction satisfy_spec:get_type()\n    return "satisfy"\nend\n\nfunction satisfy_spec:check(arguments)\n    local method = self.method\n    local description = self.description\n\n    local function check_method(arg)\n        local success, res = pcall(method, clone(arg))\n        if not success or not res then\n            err {\n                "satisfy check failed --\x3e",\n                "\\n\\tdescription: ", description,\n                "\\n\\targument: ", format(arg),\n                "\\n\\tresult: ", format_res(res, success),\n            }\n        end\n    end\n\n    foreach_arg(self, arguments, check_method)\n    return true\nend\n\nspec.satisfy = function(config)\n    guard.table("config", config)\n\n    local s = setmetatable({\n        description = require_description(config),\n        method      = require_method(config, "method"),\n        arguments   = require_arguments(config)\n    }, satisfy_spec)\n\n    if config.arguments then\n        s:check()\n    end\n\n    return s\nend\n\n-- identity spec\n\nlocal identity_spec = {}\nidentity_spec.__index = identity_spec\n\nfunction identity_spec:get_description()\n    return self.description\nend\n\nfunction identity_spec:get_type()\n    return "identity"\nend\n\nfunction identity_spec:check(arguments)\n    local methods = self.methods\n    local check_equal = self.check_equal\n    local description = self.description\n\n    local function check_methods(arg)\n        local prev_name, method = next(methods)\n\n        local success, prev_res =\n            pcall(method, clone(arg))\n            -- argument is cloned to prevent incidental\n            -- modification, as for other specs\n        if not success then\n            err {\n                "identity check failed --\x3e",\n                "\\n\\tdescription: ", description,\n                "\\n\\targument: ", format(arg),\n                "\\n\\tcurrent method: ", prev_name,\n                "\\n\\tcurrent result: ", format_err(prev_res),\n            }\n        end\n\n        for curr_name, method in next, methods, prev_name do\n            local method_success, method_res =\n                pcall(method, clone(arg))\n            local check_success, check_res\n\n            if method_success then\n                check_success, check_res =\n                    pcall(check_equal, method_res, prev_res)\n            end\n\n            if not check_success or not check_res then\n                err {\n                    "identity check failed --\x3e",\n                    "\\n\\tdescription: ", description,\n                    "\\n\\targument: ", format(arg),\n                    "\\n\\tprevious method: ", prev_name,\n                    "\\n\\tprevious result: ", format(prev_res),\n                    "\\n\\tcurrent method: ", curr_name,\n                    "\\n\\tcurrent result: ",\n                        format_res(method_res, method_success),\n                    "\\n\\tcheck result: ", method_success and\n                        format_res(check_res, check_success)\n                        or "nil"\n                }\n            end\n\n            prev_name = curr_name\n            prev_res = method_res\n        end\n    end\n\n    foreach_arg(self, arguments, check_methods)\n    return true\nend\n\nspec.identity = function(config)\n    guard.table("config", config)\n\n    local s = setmetatable({\n        description = require_description(config),\n        methods     = require_methods(config, "methods"),\n        check_equal = require_check_equal(config),\n        arguments   = require_arguments(config) \n    }, identity_spec)\n\n    if config.arguments then\n        s:check()\n    end\n\n    return s\nend\n\n-- reversability spec\n\nlocal reversability_spec = {}\nreversability_spec.__index = reversability_spec\n\nfunction reversability_spec:get_description()\n    return self.description\nend\n\nfunction reversability_spec:get_type()\n    return "reversability"\nend\n\nfunction reversability_spec:check(arguments)\n    local mid_method = self.middle_method\n    local rev_method = self.reverse_method\n    local check_equal = self.check_equal\n    local description = self.description\n\n    local function check_methods(arg)\n        local mid_success, mid_res =\n            pcall(mid_method, clone(arg))\n\n        if not mid_success then\n            err {\n                "reversability check failed --\x3e",\n                "\\n\\tdescription: ", description,\n                "\\n\\targument: ", format(arg),\n                "\\n\\tmiddle result: ", format_err(mid_res)\n            }\n        end\n\n        -- do reverse\n\n        local rev_success, rev_res =\n            pcall(rev_method, clone(mid_res))\n        local check_success, check_res\n\n        if rev_success then\n            check_success, check_res =\n                pcall(check_equal, arg, rev_res)\n        end\n\n        if not check_success or not check_res then\n            err {\n                "reversability check failed --\x3e",\n                "\\n\\tdescription: ", description,\n                "\\n\\targument: ", format(arg),\n                "\\n\\tmiddle result: ", format(mid_res),\n                "\\n\\treverse result: ",\n                    format_res(rev_res, rev_success),\n                "\\n\\tcheck result: ", rev_success and\n                    format_res(check_res, check_success)\n                    or "nil"\n            }\n        end\n    end\n\n    foreach_arg(self, arguments, check_methods)\n    return true\nend\n\nspec.reversability = function(config)\n    guard.table("config", config)\n    \n    local s = setmetatable({\n        description    = require_description(config),\n        middle_method  = require_method(config, "middle_method"),\n        reverse_method = require_method(config, "reverse_method"),\n        check_equal    = require_check_equal(config),\n        arguments      = require_arguments(config) \n    }, reversability_spec)\n\n    if config.arguments then\n        s:check()\n    end\n\n    return s\nend\n\n-- idemptency spec\n\nlocal idempotency_spec = {}\nidempotency_spec.__index = idempotency_spec\n\nfunction idempotency_spec:get_description()\n    return self.description\nend\n\nfunction idempotency_spec:get_type()\n    return "idempotency"\nend\n\nfunction idempotency_spec:check(arguments)\n    local method = self.method\n    local check_equal = self.check_equal\n    local description = self.description\n\n    local function check_method(arg)\n        local fst_success, fst_res = pcall(method, clone(arg))\n        if not fst_success then\n            err {\n                "idempotency check failed --\x3e",\n                "\\n\\tdescription: ", description,\n                "\\n\\targument: ", format(arg),\n                "\\n\\tfirst result: ", format_err(fst_res),\n            }\n        end\n\n        local snd_success, snd_res = pcall(method, clone(fst_res))\n        local check_success, check_res\n\n        if snd_success then\n            check_success, check_res =\n                pcall(check_equal, fst_res, snd_res)\n        end\n\n        if not check_success or not check_res then\n            err {\n                "idempotency check failed --\x3e",\n                "\\n\\tdescription: ", description,\n                "\\n\\targument: ", format(arg),\n                "\\n\\tfirst result: ", format(fst_res),\n                "\\n\\tsecond result: ",\n                    format_res(snd_res, snd_success),\n                "\\n\\tcheck result: ", snd_success and\n                    format_res(check_res, check_success)\n                    or "nil"\n            }\n        end\n    end\n\n    foreach_arg(self, arguments, check_method)\n    return true\nend\n\nspec.idempotency = function(config)\n    guard.table("config", config)\n    \n    local s = setmetatable({\n        description = require_description(config),\n        method      = require_method(config, "method"),\n        check_equal = require_check_equal(config),\n        arguments   = require_arguments(config)\n    }, idempotency_spec)\n    \n    if config.arguments then\n        s:check()\n    end\n\n    return s\nend\n\n-- commutativity spec\n\nlocal commutativity_spec = {}\ncommutativity_spec.__index = commutativity_spec\n\nfunction commutativity_spec:get_description()\n    return self.description\nend\n\nfunction commutativity_spec:get_type()\n    return "commutativity"\nend\n\nfunction commutativity_spec:check(arguments)\n    local method = self.method\n    local check_equal = self.check_equal\n    local description = self.description\n\n    local function check_method(arg)\n        guard.table("argument", arg)\n        local arg1 = arg[1]\n        local arg2 = arg[2]\n\n        local fst_success, fst_res =\n            pcall(method, clone(arg1), clone(arg2))\n        if not fst_success then\n            err {\n                "idempotency check failed --\x3e",\n                "\\n\\tdescription: ", description,\n                "\\n\\targument 1: ", format(arg1),\n                "\\n\\targument 2: ", format(arg2),\n                "\\n\\tfirst result: ", format_err(fst_res),\n            }\n        end\n\n        local snd_success, snd_res =\n            pcall(method, clone(arg2), clone(arg1))\n        local check_success, check_res\n\n        if snd_success then\n            check_success, check_res =\n                pcall(check_equal, fst_res, snd_res)\n        end\n        \n        if not check_success or not check_res then\n            err {\n                "idempotency check failed --\x3e",\n                "\\n\\tdescription: ", description,\n                "\\n\\targument 1: ", format(arg1),\n                "\\n\\targument 2: ", format(arg2),\n                "\\n\\tfirst result: ", format(fst_res),\n                "\\n\\tsecond result: ",\n                    format_res(snd_res, snd_success),\n                "\\n\\tcheck result: ", snd_success and\n                    format_res(check_res, check_success)\n                    or "nil"\n            }\n        end\n    end\n\n    foreach_arg(self, arguments, check_method)\n    return true\nend\n\nspec.commutativity = function(config)\n    guard.table("config", config)\n    \n    local s = setmetatable({\n        description = require_description(config),\n        method      = require_method(config, "method"),\n        check_equal = require_check_equal(config),\n        arguments   = require_arguments(config)\n    }, commutativity_spec)\n    \n    if config.arguments then\n        s:check()\n    end\n\n    return s\nend\n\nreturn spec',"@./Users/tylerling/Documents/Projects/gilatod/packages/gilatod-meido/src/spec.lua").call("./spec.lua")},630:(n,e,t)=>{var r=t(911),a=r.lua,o=r.lauxlib,l=r.L,c=r.interop.push;o.luaL_getsubtable(l,a.LUA_REGISTRYINDEX,o.LUA_PRELOAD_TABLE),a.lua_pushcfunction(l,(function(n){return c(n,t(93)),1})),a.lua_setfield(l,-2,r.to_luastring("guard")),a.lua_pushcfunction(l,(function(n){return c(n,t(708)),1})),a.lua_setfield(l,-2,r.to_luastring("meta")),a.lua_pushcfunction(l,(function(n){return c(n,t(211)),1})),a.lua_setfield(l,-2,r.to_luastring("pattern")),a.lua_pop(l,1),n.exports=r.load('local guard = require("guard")\nlocal meta = require("meta")\nlocal pattern = require("pattern")\n\nlocal readonly = meta.readonly\n\nlocal format = string.format\n\nlocal struct = {}\nstruct.__index = struct\n\nlocal CALLBACKS_KEY = readonly {}\n\nlocal property_entry = setmetatable({}, {\n    __call = function(self, t)\n        return setmetatable(t, self)\n    end\n})\nproperty_entry.__index = property_entry\nproperty_entry.__metatable = "readonly"\n\nfunction property_entry:get_type()\n    return self[1]\nend\n\nfunction property_entry:guard(name, value)\n    self[2](name, value)\nend\n\nfunction property_entry:get_default()\n    return self[3]\nend\n\nlocal OPTIONAL_BYTE = string.byte(\'?\')\n\nlocal type_defaults = {\n    ["string"]   = "",\n    ["number"]   = 0,\n    ["table"]    = pattern.TABLE:get_default(),\n    ["function"] = pattern.FUNCTION:get_default(),\n    ["boolean"]  = false,\n    ["any"]      = false\n}\n\nlocal function register_raw_prop(prop_name, prop_type, prop_default)\n    guard.nonempty_string("property name", prop_name)\n    guard.nonempty_string("property type", prop_type)\n    \n    local optional\n\n    if prop_type:byte(#prop_type) == OPTIONAL_BYTE then\n        prop_type = prop_type:sub(1, #prop_type - 1)\n        optional = true\n    end\n\n    local type_default = type_defaults[prop_type]\n    if type_default == nil then\n        error(format(\n            "unrecognized type for \'%s\': %s",\n            prop_name, prop_type), 3)\n    end\n\n    if optional then\n        type_default = nil\n    end\n\n    if prop_default ~= nil then\n        if type(prop_default) ~= prop_type then\n            error(format(\n                "invalid default value for \'%s\' (%s expected, got %s)",\n                prop_name, prop_type, type(prop_default)), 3)\n        end\n\n        if prop_type == "table"\n            and getmetatable(prop_default) ~= "readonly" then\n            error(format(\n                "default value for \'%s\' must be read-only, or "..\n                "it could be modified unexpectedly",\n                prop_name), 3)\n        end\n    else\n        prop_default = type_default\n    end\n\n    local prop_guard\n\n    if prop_type == "any" then\n        if optional then\n            prop_guard = function(prop_name, value)\n                -- do nothing\n            end\n        else\n            prop_guard = function(prop_name, value)\n                if value == nil then\n                    error(format(\n                        "invalid value for \'%s\' (non-nil value expected)",\n                        prop_name), 3)\n                end\n            end\n        end\n    else\n        if optional then\n            prop_guard = function(prop_name, value)\n                if type(value) ~= prop_type\n                    and value ~= nil then\n                    error(format(\n                        "invalid value for \'%s\' (%s or nil expected, got %s)",\n                        prop_name, prop_type, type(value)), 3)\n                end\n            end\n        else\n            prop_guard = function(prop_name, value)\n                if type(value) ~= prop_type then\n                    error(format(\n                        "invalid value for \'%s\' (%s expected, got %s)",\n                        prop_name, prop_type, type(value)))\n                end\n            end\n        end\n    end\n\n    prop_guard(prop_name, prop_default) -- check default value\n    return property_entry {prop_type, prop_guard, prop_default}\nend\n\nlocal function register_pattern_prop(prop_name, pat, prop_default)\n    local function guard(prop_name, value)\n        if not pat:match(value) then\n            error(format(\n                "invalid value for \'%s\' (pattern: %s)",\n                prop_name, pat:get_description()), 3)\n        end\n    end\n\n    if prop_default then\n        guard(prop_name, prop_default)\n    elseif pat:has_default() then\n        prop_default = pat:get_default()\n    end\n\n    return property_entry {pat, guard, prop_default}\nend\n\nlocal function create_struct(self, config)\n    local s = {}\n    s.__index = s\n\n    local props = {}\n    s.props = props\n\n    local function trigger_callbacks(s, prop_name, value)\n        local funcs = s[CALLBACKS_KEY][prop_name]\n        if funcs then\n            for f in pairs(funcs) do\n                f(s, prop_name, value)\n            end\n        end\n    end\n\n    for prop_name, prop_cfg in pairs(config) do\n        local entry\n\n        if type(prop_cfg) == "string" then\n            entry = register_raw_prop(prop_name, prop_cfg)\n        elseif getmetatable(prop_cfg) == pattern then\n            entry = register_pattern_prop(prop_name, prop_cfg)\n        else\n            guard.table("property config", prop_cfg)\n\n            local prop_type = prop_cfg[1]\n            local prop_default = prop_cfg[2]\n\n            if getmetatable(prop_type) == pattern then\n                entry = register_pattern_prop(\n                    prop_name, prop_type, prop_default)\n            else\n                entry = register_raw_prop(\n                    prop_name, prop_type, prop_default)\n            end\n        end\n\n        props[prop_name] = entry\n\n        local prop_type = entry[1]\n        local prop_guard = entry[2]\n\n        local setter_prefix, getter_prefix\n\n        if prop_type == "boolean" then\n            setter_prefix = "set_"\n            getter_prefix = "is_"\n        else\n            setter_prefix = "set_"\n            getter_prefix = "get_"\n        end\n\n        local setter_name = setter_prefix..prop_name\n\n        s[setter_name] = function(self, value)\n            prop_guard(prop_name, value)\n            self[prop_name] = value\n            trigger_callbacks(self, prop_name, value)\n        end\n\n        s["unsafe_"..setter_name] = function(self, value)\n            self[prop_name] = value\n            trigger_callbacks(self, prop_name, value)\n        end\n        \n        s[getter_prefix..prop_name] = function(self)\n            return self[prop_name]\n        end\n    end\n\n    function s:set(prop_name, value)\n        local entry = props[prop_name]\n        local prop_guard = entry[2]\n\n        prop_guard(prop_name, value)\n        self[prop_name] = value\n        trigger_callbacks(self, prop_name, value)\n    end\n\n    function s:unsafe_set(prop_name, value)\n        local entry = props[prop_name]\n        local prop_guard = entry[2]\n\n        self[prop_name] = value\n        trigger_callbacks(self, prop_name, value)\n    end\n\n    function s:get(prop_name)\n        return self[prop_name]\n    end\n\n    function s:reset(prop_name)\n        if prop_name then\n            local prop_default = props[prop_name][3]\n            self[prop_name] = prop_default\n            trigger_callbacks(self, prop_name, prop_default)\n        else\n            for prop_name, prop_cfg in pairs(props) do\n                local prop_default = prop_cfg[3]\n                self[prop_name] = prop_default\n                trigger_callbacks(self, prop_name, prop_default)\n            end\n        end\n    end\n\n    function s:notify(prop_name, callback)\n        self:notify_change(prop_name, callback)\n        callback(self, prop_name, self[prop_name])\n    end\n\n    local function raw_notify_change(self, prop_name, callback)\n        local entries = self[CALLBACKS_KEY]\n        local funcs = entries[prop_name]\n\n        if not funcs then\n            funcs = {}\n            entries[prop_name] = funcs\n        end\n\n        funcs[callback] = true\n    end\n\n    function s:notify_change(prop_name, callback)\n        guard.nonempty_string("prop_name", prop_name)\n        guard.callable("callback", callback)\n\n        if not props[prop_name] then\n            error("invalid property: "..prop_name)\n        end\n\n        raw_notify_change(self, prop_name, callback)\n    end\n\n    function s:unnotify(prop_name, callback)\n        guard.nonempty_string("prop_name", prop_name)\n        guard.callable("callback", callback)\n\n        if not props[prop_name] then\n            error("invalid property: "..prop_name)\n        end\n\n        local entries = self[CALLBACKS_KEY]\n        local funcs = entries[prop_name]\n\n        if not funcs or not funcs[callback] then\n            return\n        end\n\n        funcs[callback] = nil\n    end\n\n    function s:create_mapper(target, entries)\n        guard.table("entries", entries)\n\n        local prop_map = {}\n\n        for i = 1, #entries do\n            local entry = entries[i]\n\n            local prop_name\n            local target_field_name\n            local mapper\n\n            if type(entry) == "string" then\n                prop_name = entry\n                target_field_name = entry\n            else\n                prop_name = entry[1]\n                target_field_name = entry[2]\n                mapper = entry[3]\n\n                guard.nonempty_string(\n                    "prperty name", prop_name)\n\n                if type(target_field_name) ~= "string" then\n                    -- simple property handler\n                    mapper = entry[2]\n                    target_field_name = nil\n                    guard.callable("property handler", mapper)\n                else\n                    guard.nonempty_string(\n                        "target field name", target_field_name)\n                    if mapper then\n                        guard.callable("property mapper", mapper)\n                    end\n                end\n            end\n\n            if not props[prop_name] then\n                error("invalid property: "..prop_name)\n            end\n\n            if mapper then\n                if target_field_name then\n                    prop_map[prop_name] = {target_field_name, mapper}\n                else\n                    prop_map[prop_name] = mapper\n                end\n            else\n                prop_map[prop_name] = target_field_name\n            end\n        end\n\n        local function callback(self, prop_name, value)\n            local entry = prop_map[prop_name]\n            local entry_type = type(entry)\n\n            if entry_type == "string" then\n                target[entry] = value\n            elseif entry_type == "table" then\n                target[entry[1]] = entry[2](value)\n            else\n                entry(target, value)\n            end\n        end\n\n        for i = 1, #entries do\n            local entry = entries[i]\n            local prop_name = type(entry) == "string"\n                and entry or entry[1]\n\n            raw_notify_change(self, prop_name, callback)\n            callback(self, prop_name, self[prop_name])\n        end\n\n        local function unregister()\n            -- do not use `entries`: it might have been modified\n            for prop_name in pairs(prop_map) do\n                self:unnotify(prop_name, callback)\n            end\n        end\n\n        return unregister\n    end\n\n    s.get_properties = function()\n        return props\n    end\n\n    readonly(props)\n    return setmetatable(s, struct)\nend\n\nfunction struct:__call(config)\n    local t = setmetatable({[CALLBACKS_KEY] = {}}, self)\n\n    local props = self.props\n    for prop_name, entry in pairs(props) do\n        t[prop_name] = entry[3] \n    end\n\n    if not config then\n        return t\n    end\n\n    guard.table("config", config)\n\n    for prop_name, value in pairs(config) do\n        local entry = props[prop_name]\n\n        if entry then\n            local prop_guard = entry[2]\n            prop_guard(prop_name, value)\n            t[prop_name] = value\n            -- no callback for triggeriing\n        elseif type(prop_name) == "string" then\n            error("invalid property: "..tostring(prop_name))\n        end\n    end\n\n    return t\nend\n\nreturn setmetatable(struct, {\n    __call = create_struct\n})',"@./Users/tylerling/Documents/Projects/gilatod/packages/gilatod-meido/src/struct.lua").call("./struct.lua")}},n=>{n.O(0,[216],(()=>(620,n(n.s=620)))),n.O()}]);